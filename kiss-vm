#!/usr/bin/env bash
# author: yin-jianhong@163.com
# test pass on RHEL-7/CentOS-7, RHEL-8/CentOS-8 RHEL-9/CentOS-9s and Fedora-{29..41}
#
# inspired by https://www.brianlinkletter.com/2019/02/build-a-network-emulator-using-libvirt/
# `and inspired by Red Hat traning Virtual Lab

PATH=~/bin:$PATH 

#>================ for recall self if something happen ================
CPID=$$
PROG=$0
ARGS=("$@")
trap_try_again() {
	echo "[Error] got a special issue($SA_SIGINFO) while create VM, try again:";
	echo '----------------------------------------------------------------'
	VM_RETRY=yes exec $PROG "${ARGS[@]}" -f;
}
trap_try_newcpu() {
	local cpu=Icelake-Server
	echo "[Error] got a special issue($SA_SIGINFO) while create VM, try again:";
	echo '----------------------------------------------------------------'
	PATH=/usr/libexec:$PATH LANG=C qemu-kvm -cpu ?|grep -q $cpu || cpu=Skylake-Server
	VM_RETRY=yes exec $PROG "${ARGS[@]}" -f --cpu=$cpu;
}
trap trap_try_again SIGUSR2
trap trap_try_newcpu SIGALRM
downhostname=download.devel.redhat.com
LOOKASIDE_BASE_URL=${LOOKASIDE:-http://${downhostname}/qa/rhts/lookaside}
#<================ for recall self if something happen ================

P=$0; [[ $0 = /* ]] && P=${0##*/}
_repon=kiss-vm-ns
_confdir=/etc/$_repon
varlib_dir=/var/lib/kiss-vm
Distro=
Location=
Imageurl=
VM_OS_VARIANT=
OVERWRITE=no
KSPath=
ksauto=
MacvtapMode=bridge
VMName=
InstallType=import
VirtInstallTimeOut=600

VMUSER=$(whoami)
[[ $(id -u) = 0 && -n "$SUDO_USER" ]] && VMUSER=$SUDO_USER
eval VMUSERHOME=~$VMUSER
VMSHOME=${VMUSERHOME}/VMs
ImagePath=${VMUSERHOME}/myimages
perConfDir=${VMUSERHOME}/.config/${_repon}
oldperConfDir=${VMUSERHOME}/.config/kiss-vm

VM_DOMAIN=lab.kissvm.net
RuntimeTmp=/tmp/vm-$$
INTERACT=yes
Intranet=yes
VIRT_READY=unkown
_MSIZE=2048M
DSIZE=64
baudrate=115200
DEFAULT_GRAPHICS_CONF="vnc,listen=0.0.0.0"
HostARCH=$(uname -m)
GuestARCH=$HostARCH
#VIDEO_OPT="--video=qxl"
SOUND_OPT="--sound=default"
QEMU_OPTS=()
QEMU_ENV=()
baseUrl=${LOOKASIDE_BASE_URL}/kiss-vm-ns
bkrClientImprovedUrl=${LOOKASIDE_BASE_URL}/bkr-client-improved
VCPUS=${VCPUS:-8,sockets=1,cores=8}
DEFAULT_DISK_BUS=virtio
DEFAULT_IF_MODEL=virtio
defaultPasswd=redhat
defaultWindowsPasswd=Sesame~0pen
orig_disable_ipv6=$(/sbin/sysctl -n net.ipv6.conf.all.disable_ipv6 2>/dev/null)
{ QEMU_USER=qemu; { ! id ${QEMU_USER} &>/dev/null || id libvirt-qemu &>/dev/null; } && QEMU_USER=libvirt-qemu; }

#workaround for creating Windows VM fail with virt-install-5.0
virtinstVer=$(virt-install --version 2>/dev/null)

quote() {
	local at=$1
	if [[ -z "$at" ]]; then
		echo -n "'' "
	elif [[ "$at" =~ [^[:print:]]+ || "$at" = *$'\t'* || "$at" = *$'\n'* ]]; then
		builtin printf %q "$at"; echo -n " "
	elif [[ "$at" =~ "'" && ! "$at" =~ ([\`\"$]+|\\\\) ]]; then
		echo -n "\"$at\" "
	else
		echo -n "$at" | sed -r -e ':a;$!{N;ba};' \
			-e "s/'+/'\"&\"'/g" -e "s/^/'/" -e "s/$/' /" \
			-e "s/^''//" -e "s/'' $/ /"
	fi
}
getReusableCommandLine() {
	#if only one parameter, treat it as a piece of script
	[[ $# = 1 ]] && { echo "$1"; return; }

	local shpattern='^[][0-9a-zA-Z~@%^_+=:,./-]+$'

	for at; do
		if [[ "$at" =~ $shpattern ]]; then
			echo -n "$at "
		else
			quote "$at"
		fi
	done
	echo
}

run() {
	#ref: https://superuser.com/questions/927544/run-command-in-detached-tmux-session-and-log-console-output-to-file
	local _runtype= _debug= _rc=0
	local _nohup= _nohuplogf=
	local _user= _SUDO=
	local _default_nohuplogf=${VMpath:-.}/nohup.log
	local _tmuxSession= _tmuxlogf=

	while true; do
		case "$1" in
		-d|-debug) _debug=yes; shift;;
		-eval*) _runtype=eval; shift;;
		-bash*) _runtype=bash; shift;;
		-tmux*) _runtype=tmux;
			[[ $1 = *=* ]] && _tmuxSession=${1#*=}
			_tmuxSession=${_tmuxSession:-$$-${USER}}
			_tmuxlogf=${VMpath:-/tmp}/run-tmux-${_tmuxSession}.log
			shift;;
		-nohu*) _nohup=yes
			[[ $1 = *=* ]] && _nohuplogf=${1#*=}
			_nohuplogf=${_nohuplogf:-$_default_nohuplogf}
			shift;;
		-as=*)  _U=${1#*=}; [[ "$_U" = "$USER" ]] || _SUDO="sudo -u $_U"; shift;;
		-*)     shift;;
		*)      break;;
		esac
	done

	[[ $# -eq 0 ]] && return 0
	[[ $# -eq 1 && -z "$_runtype" ]] && _runtype=eval
	[[ "${_runtype}" = eval && -n "$_SUDO" ]] && _SUDO+=\ -s
	local _cmdl=$(getReusableCommandLine "$@")
	local _cmdlx=

	if [[ "$_debug" = yes ]]; then
		_cmdlx=$_cmdl
		if [[ "${_runtype}" = tmux ]]; then
			_cmdlx="tmux new -s $_tmuxSession -d \"$_cmdl\" \\; pipe-pane \"cat >$_tmuxlogf\""
		elif [[ "$_nohup" = yes ]]; then
			_cmdlx="nohup $_cmdl &>${_nohuplogf} &"
		fi
		[[ -n "$_SUDO" ]] && _cmdlx="[$_SUDO] $_cmdlx"
		echo $'\E[0;33;44m'"[${_runtype:-plat} run] ${_cmdlx}"$'\E[0m'
	fi

	case ${_runtype:-plat} in
	plat)
		if [[ -n "$_nohup" ]]; then
			$_SUDO touch "${_nohuplogf}"
			$_SUDO nohup "$@" &>${_nohuplogf} &
		else
			$_SUDO "$@"; _rc=$?
		fi
		;;
	eval)   $_SUDO eval "$_cmdl"; _rc=$?;;
	bash)   $_SUDO bash -c "$_cmdl"; _rc=$?;;
	tmux)   $_SUDO tmux new -s $_tmuxSession -d "$_cmdl" \; pipe-pane "cat >$_tmuxlogf"; _rc=$?;;
	esac

	return $_rc
}

cvirsh() { LANG=C virsh "$@"; }

is_ssh() {
	local p=${1:-$PPID}
	read pid name x ppid y < <(cat /proc/$p/stat)
	# or: read pid name ppid < <(ps -o pid= -o comm= -o ppid= -p $p) 
	[[ "$name" =~ sshd ]] && { echo "Is SSH: $pid $name"; return 0; }
	[ "$ppid" -le 1 ]     && { echo "Root is $pid $name"; return 1; }
	is_ssh $ppid
}

try_disable_ipv6() {
	[[ $(id -u) != 0 ]] && return 1
	who am i|grep -v '([0-9a-f:]\+)$' && /sbin/sysctl -w net.ipv6.conf.all.disable_ipv6=1
}

create_vmhome() {
	local vmhome=${1%/}
	local vmn=${vmhome##*/}
	if [[ -z "$vmhome" ]]; then
		echo "{VM:ERROR} create_vmhost <vmhome>: argument vmhome is required" >&2
		return 1
	fi
	VMtmp=$vmhome/tmp
	homedirf=$varlib_dir/${vmn}/homedir
	run -debug -as=$VMUSER mkdir -p $vmhome $VMtmp $varlib_dir/${vmn}
	run -debug -as=$VMUSER bash -c "echo $vmhome >$homedirf"
	run -as=$VMUSER "chmod 1777 $VMtmp; chcon --reference=/tmp $VMtmp 2>/dev/null"
	setfacl -mu:${QEMU_USER}:rwx -mg:${QEMU_USER}:rwx ${vmhome%/*} ${vmhome} 2>/dev/null
	#ensure files created in VMtmp can be accessed by others
	setfacl -PRdm u::rwx,g::rwx,o::rx ${VMtmp}
}

at_exit() {
	#echo -e "\n\n{VM:debug} Removing tmpdir: $RuntimeTmp"
	[[ $(id -u) = 0 ]] && /sbin/sysctl -w net.ipv6.conf.all.disable_ipv6=$orig_disable_ipv6 &>/dev/null
	rm -rf $RuntimeTmp
}
kill_installer_tmux_session() {
	local _vmn=$1
	[[ -z "$_vmn" ]] && return
	while read session _ ; do
		[[ "$session" = *_${_vmn}: ]] && tmux kill-session -t ${session%:}
	done < <(tmux ls 2>/dev/null)
}
kill_virt_viewer() {
	local _vm=$1
	[[ -z "$_vm" ]] && return
	local _pid=$(ps axf|awk -vvm=$_vm '$0 ~ ".*virt-viewe[r].*-r "vm"$" {print $1}')
	[[ -n "$_pid" ]] && { kill $_pid; }
}
cleanup_and_exit() {
	if [[ -n "$VMpath" ]]; then
		echo -e "\n{VM:clean} Removing VM dir: $VMpath"
		rm -rfv "$VMpath"
		rmdir -v "${VMpath%/*}" 2>/dev/null

		echo -e "{VM:clean} kill installer assistant tmux session"
		kill_installer_tmux_session ${VMpath##*/}
	fi
	exit ${1:-0}
}
trap cleanup_and_exit SIGINT SIGQUIT SIGTERM
trap at_exit EXIT
#-------------------------------------------------------------------------------

vcpuN() {
	local _vcpus=$1
	local _vcpun= _sockets=1 _cores=4 _threads=1
	for _item in ${_vcpus//,/ }; do
		case $_item in
		[0-9]*) _vcpun=$_item;;
		sockets=*) _sockets=${_item#*=};;
		cores=*) _cores=${_item#*=};;
		threads=*) _threads=${_item#*=};;
		esac
	done

	if [[ -z "$_vcpun" ]]; then
		_vcpun=$((_sockets * _cores * _threads))
	fi

	echo -n $_vcpun
}

vmname_gen() {
	local distro=$1
	local cname=$2
	local name=${Distro//./}
	local archsuffix=
	name=${name,,}

	if [[ -n "$cname" ]]; then
		name=${cname//[._]/-}
	else
		[[ "$GuestARCH" != "$HostARCH" ]] && archsuffix="_$GuestARCH"
		name=${VMUSER}-${name}$archsuffix
	fi
	echo -n $name
}

vmname_extract() {
	local allopt=
	[[ "$1" = -all || "$1" = --all ]] && { shift; allopt=--all; }

	local i=0
	for vm; do
		let i=0
		for _vm in $(virsh list --name ${allopt}); do
			[[ "$_vm" = $vm ]] && { echo $_vm; let i++; }
		done
		[[ $i -eq 0 ]] && echo "$vm"
	done
}

_vmblklist() {
	local _vmname=$(vmname_extract -all "$1"|head -n1)
	local _pat=${2:-.}
	[[ -z "$_vmname" ]] && {
		echo "Usage: vmblklist <vmname> [pattern]"
		return 1
	}

	local blklist=$(cvirsh domblklist "$_vmname" --details | awk 'NR>2{print}' | sed -r '/^$/d')
	if [[ -z "$(grep -E -v 'cdrom|ansf-usb.image' <<<"$blklist")" ]]; then
		blklist+=$'\n'$(virsh dumpxml "$_vmname" |
			sed -rn '/qemu:commandline/,/\/qemu:commandline/{/.*file=([^,]+),.*,id=NVME.*/I{s//file disk nvme \1/;p}}')
	fi
	echo "$blklist" | grep -E "/$_vmname/"     | grep -E "$_pat"
	echo "$blklist" | grep -E -v "/$_vmname/"  | grep -E "$_pat"
}

vmrootdir() {
	pushd $VMSHOME >/dev/null
	pwd
	ls -l
	popd >/dev/null
}

vmhomedir() {
	local _vmname= _vmdir=
	_vmname=$(vmname_extract -all "$@")

	if test -z "$_vmname"; then
		echo "{VM:WARN} a vmname is needed" >&2
		return 1
	fi

	for vmn in $_vmname; do
		virsh desc $vmn &>/dev/null || {
			echo -e "{VM:WARN} VM $vmn not exist!" >&2; continue
		}
		_vmdir=$(cat $varlib_dir/$vmn/homedir 2>/dev/null)
		if test -z "$_vmdir"; then
			_vmdir=$(ls -d $VMSHOME/*/$vmn 2>/dev/null|head -1)
			if test -z "$_vmdir"; then
				echo "{VM:ERR} [$vmn] get home dir fail, something is wrong" >&2
				continue
			fi
		fi

		if pushd $_vmdir &>/dev/null; then
			pwd
			ls -lAhZ
			popd >/dev/null
			test -f $_vmdir/.kiss-vm ||
				echo "{VM:NOTE} seems this VM is not created by kiss-vm($(command -v vm))" >&2
		else
			echo "$_vmdir"
			ls -lAhZ "$_vmdir" ||
				echo "{VM:WARN} current user($(whoami)) can not access the ^^ VM homedir ^^" >&2
		fi
		echo
	done
}

_vmdelete() {
	local _vmname=$1
	[[ -z "$_vmname" ]] && {
		return 1
	}

	grep -E -q "^${_vmname//+/.}$" <(virsh list --name --all) || {
		echo -e "{VM:WARN} VM '$_vmname' does not exist" >&2
		return 1
	}

	local userhome=$(getent passwd "$VMUSER" | cut -d: -f6)
	local _vmdir=$(vmhomedir $_vmname 2>/dev/null|head -n1)
	local own=no
	local delOpts=
	[[ -n "$(virsh snapshot-list $_vmname --name)" ]] && delOpts=--snapshots-metadata
	[[ $(id -u) = 0 && $_vmdir = /root/VM[sS]/* ]] || [[ "$_vmdir" = $userhome/VM[sS]/* ]] && own=yes
	if [[ $own != yes ]]; then
		echo -e "{VM:WARN} VM '$_vmname' was not created by current user($VMUSER); try:" >&2
		cat <<-EOF >&2
		  virsh destroy $_vmname
		  virsh undefine $_vmname $delOpts #--remove-all-storage --nvram
		EOF
		return 1
	fi

	echo -e "\n{VM:INFO} => dist removing VM $_vmname .."
	{ virsh destroy $_vmname 2>/dev/null; sleep 0.5
	  virsh undefine $_vmname $delOpts 2>/dev/null || virsh undefine $_vmname --nvram; } | sed '/^$/d'

	echo -e "{VM:INFO} kill virt-viewer/tmux-session of $_vmname ..."
	kill_installer_tmux_session ${_vmname}
	kill_virt_viewer ${_vmname}

	echo -e "{VM:INFO} removing VM folder $_vmdir ..."
	rm -rf $varlib_dir/$_vmname
	rm -f $_vmdir/{url,nohup.log,ext4.qcow2,xfs.qcow2,vm.xml,qemu.argv,.kiss-vm}
	rm -f $_vmdir/*.cfg $_vmdir/*.ks
	rm -f $_vmdir/*.qcow2.xz $_vmdir/*.img $_vmdir/*.image
	rm -f $_vmdir/nvdimm-*.dev
	rm -f $(sed 's/^unix://' $_vmdir/tmp/monitor.unix 2>/dev/null)
	rm -fr $_vmdir/tmp
	rm -f $_vmdir/*
	rmdir $_vmdir 2>/dev/null
	rmdir ${_vmdir%/*} 2>/dev/null
	return 0
}

vmdialogchecklist() {
	local cmdinfo=$1
	local resfile=$2
	local all=$3
	local vmlist=$(virsh list --name ${all:+--all})
	[[ -n "$VMUSER" ]] && vmlist=$(grep "^$VMUSER" <<<"$vmlist"; grep -v "^$VMUSER" <<<"$vmlist";)
	local vmList=$(echo "$vmlist" | sed -e /^$/d -e 's/.*/"&" "" 1/')
	[[ -z "${vmList}" ]] && {
		echo -e "{VM:WARN} there is not any VM in your host .." >&2
		return 1;
	}
	dialog --backtitle "$cmdinfo" --separate-output --checklist "${cmdinfo}: please select vms you want " 30 120 28 $vmList 2>$resfile; rc=$?
	tput cup $(tput lines) 0
	return $rc
}
vmdialogradiolist() {
	local cmdinfo=$1
	local resfile=$2
	local all=$3
	local vmlist=$(virsh list --name ${all:+--all})
	[[ -n "$VMUSER" ]] && vmlist=$(grep "^$VMUSER" <<<"$vmlist"; grep -v "^$VMUSER" <<<"$vmlist";)
	local vmList=$(echo "$vmlist" | sed -e /^$/d -e 's/.*/"&" "" 1/')
	[[ -z "${vmList}" ]] && {
		echo -e "{VM:WARN} there is not any VM in your host .." >&2
		return 1;
	}
	dialog --backtitle "$cmdinfo" --radiolist "${cmdinfo}: please select vm you want " 30 60 28 $vmList 2>$resfile; rc=$?
	tput cup $(tput lines) 0
	return $rc
}

vmdelete() {
	[[ $# = 0 ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogchecklist vm-delete $resf all && rmList=$(< $resf)
		[[ -z "$rmList" ]] && { return; }
		eval set $rmList
	}
	set -- $(vmname_extract -all "$@")
	for vm; do _vmdelete $vm; done
}

vmiflist() {
	local _vmname=$(vmname_extract -all "$1")
	[[ -z "$_vmname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogradiolist vm-iflist $resf all && _vmname=$(sed 's/"//g' $resf)
		[[ -z "$_vmname" ]] && { return; }
	}
	virsh domiflist "$_vmname" | awk 'NR>2&&$NF'
}

vmifunplugin() {
	local _vmname=$(vmname_extract -all "$1")
	local _ifid=$2
	[[ $_ifid = [0-9] ]] && _ifid=$(vmiflist $_vmname|awk "NR==${_ifid}{print \$NF}")
	[[ -z "$_ifid" ]] && { echo "{WARN} Usage: $0 <vmname> <if-mac|if-srcname|if-number>" >&2; return 1; }
	run -debug virsh domif-setlink "$_vmname" "$_ifid" down
}

vmifplugin() {
	local _vmname=$(vmname_extract -all "$1")
	local _ifid=$2
	[[ $_ifid = [0-9] ]] && _ifid=$(vmiflist $_vmname|awk "NR==${_ifid}{print \$NF}")
	[[ -z "$_ifid" ]] && { echo "{WARN} Usage: $0 <vmname> <if-mac|if-srcname|if-number>" >&2; return 1; }
	run -debug virsh domif-setlink "$_vmname" "$_ifid" up
}

vmifaddr() {
	local GETENT=
	local VERBOSEIF=
	while :; do
		case "$1" in
		/x) GETENT=yes; shift;;
		/v) VERBOSEIF=yes; shift;;
		*)  break;;
		esac
	done

	local _vmname=$(vmname_extract -all "$1")
	VERBOSEIF=${2:+yes}
	[[ -z "$_vmname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogradiolist vm-ifaddr $resf && _vmname=$(sed 's/"//g' $resf)
		[[ -z "$_vmname" ]] && { return; }
	}

	local addrs=
	if [[ "$GETENT" = yes ]]; then
		addrs=$(getent hosts "$_vmname"|awk '{print $1}'|tac)
	else
		addrs=$(virsh --quiet domifaddr "$_vmname" | awk '{print $4}')
		if [[ -z "$VERBOSEIF" ]]; then
			addrs=$(echo "$addrs" | awk -F/ '{print $1}')
		fi
	fi
	[[ -n "$addrs" ]] && echo "$addrs"
}

vmviewer() {
	echo "{VM:INFO} redirect to: virt-viewer -s -v -r ..."
	local logf=$RuntimeTmp/vmviewer-$$.log
	local waitopt=
	[[ "$WAIT" = yes ]] && waitopt=-w

	set -- $(vmname_extract "$@")
	kill_virt_viewer "$@"
	run -debug -nohup=$logf virt-viewer -s -v -r $waitopt "$@"
	sleep 1; cat $logf 2>/dev/null
}

vncgetsc() {
	local vncport=$1
	local _vmname=$(vmname_extract -all "$2")

	! command -v vncdo >/dev/null && {
		echo "{VM:WARN} command vncdo is needed by 'vncgetsc/vncgetscreen' function!" >&2
		return 1
	}
	local fname=$_vmname-screen-$(date +%F_%T_%N).png
	vncdo -s $vncport capture $RuntimeTmp/_screen.png
	if [[ "$INVERT" = yes || -n "$ThresHold" ]]; then
		image_binarize $RuntimeTmp/_screen.png $fname invert=${INVERT:-no} threshold=${ThresHold}
	else
		mv $RuntimeTmp/_screen.png $fname
	fi
	ls -lh $fname
	if [[ -n $DISPLAY ]]; then
		RM=yes
		if command -v eom &>/dev/null; then
			run -debug eom $fname
		elif command -v eog &>/dev/null; then
			run -debug eog $fname
		elif command -v qview &>/dev/null; then
			run -debug qview $fname
		else
			RM=no
		fi
		[[ "$RM" = yes ]] && { sleep 0.1; rm -f $fname; }
	fi
}

image_binarize() {
	local srcf=${1}
	local dstf=${2:-new-${srcf}}
	local invert=${3#invert=}
	local threshold=${4#threshold=} _hold=

	threshold=${threshold:-50%}
	_hold=0.${threshold%\%}
	GMFirst=${GMFirst:-no}
	if command -v anytopnm >/dev/null; then
		if [[ "$invert" = yes ]]; then
			anytopnm $srcf | ppmtopgm | pgmtopbm -threshold -value ${_hold} | pnminvert | pnmtopng > $dstf
		else
			anytopnm $srcf | ppmtopgm | pgmtopbm -threshold -value ${_hold}| pnmtopng > $dstf
		fi
	else
		local ConvertCmd="gm convert"
		[[ "$invert" = yes ]] && negateOpt=-negate
		! command -v gm >/dev/null && {
			if ! command -v convert >/dev/null; then
				echo "{VM:WARN} command gm or convert are needed by 'image_binarize' function!" >&2
				return 1
			else
				ConvertCmd=convert
			fi
		}
		$ConvertCmd $srcf -threshold ${threshold%\%}% $negateOpt $dstf
	fi

	return 0
}

vncget() {
	local vncport=${1}
	local ocrtool=${2}

	! command -v vncdo >/dev/null && {
		echo "{VM:WARN} command vncdo is needed by 'vncget' function!" >&2
		return 1
	}
	! command -v gocr >/dev/null && ! command -v tesseract >/dev/null &&  {
		echo "{VM:WARN} command gocr or tesseract is needed by 'vncget' function!" >&2
		return 1
	}
	vncdo -s $vncport capture $RuntimeTmp/_screen.png
	[[ ! -s $RuntimeTmp/_screen.png ]] && {
		echo "{VM:WARN} vncdo capture fail, it might because that conflict with unshared 'virt-viewer'" >&2
	}
	image_binarize $RuntimeTmp/_screen.png $RuntimeTmp/_screen2.png invert=$INVERT threshold=${ThresHold}
	[[ -n "$ocrtool" ]] && shift 2 || { ocrtool=gocr; shift 1; }
	case $ocrtool in
	gocr)
		gocr -i $RuntimeTmp/_screen2.png "${@}" 2>/dev/null | GREP_COLORS='ms=30;47' grep --color .
		;;
	tesseract|tesser*)
		tesseract $RuntimeTmp/_screen2.png - "${@}" 2>/dev/null | GREP_COLORS='ms=30;47' grep --color .
		;;
	esac
}

vncput() {
	local vncport=$1
	shift

	command -v vncdo >/dev/null || {
		echo "{VM:WARN} vncdo is needed by 'vncput' function!" >&2
		return 1
	}

	local msgArray=()
	for msg; do
		[[ -z "$msg" ]] && { msgArray+=(); continue; }
		case "$msg" in
		key:*|keyup:*|keydown:*)
			msgArray+=("$msg")
			;;
		*)
			regex='[~@#$%^&*()_+|}{":?><!]'
			_msg="${msg#type:}"
			if [[ "$_msg" =~ $regex ]]; then
				while IFS= read -r line; do
					if [[ "$line" = key:shift-? ]]; then
						: #line=key:shift-$(tr ')~!@#$%^&*(+}{|:><?"'   '0`123456789=][\\;.,/'"'" <<<"${line: -1}")
					else
						line="type:$line"
					fi
					msgArray+=("$line")
				done < <(sed -r -e 's;[~!@#$%^&*()_+|}{":?><]+;&\n;g' -e 's;[~!@#$%^&*()_+|}{":?><];\nkey:shift-&;g' <<<"$_msg")
			else
				msgArray+=("$msg")
			fi
			;;
		esac
		msgArray+=("")
	done
	for msg in "${msgArray[@]}"; do
		[[ -z "${msg}" ]] && { sleep 0.5; continue; }
		[[ "${msg}" = key:sleep:* ]] && { sleep ${msg#key:sleep:}; continue; }
		case "$msg" in
		key:*)     vncdo --force-caps -s $vncport key "${msg#key:}";;
		keyup:*)   vncdo --force-caps -s $vncport keyup "${msg#keyup:}";;
		keydown:*) vncdo --force-caps -s $vncport keydown "${msg#keydown:}";;
		*)         vncdo --force-caps -s $vncport type "${msg#type:}";;
		esac
	done
}

_vmvncport() {
	local _vmn=$1;
	virsh dumpxml "$_vmn" | sed -rn "/.* type=.vnc. port=.([0-9]+).*/{s//\1/;p}";
}
vmvncproc() {
	local _vmname=$(vmname_extract -all "$1")
	[[ -z "$_vmname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogradiolist vm-vncproc $resf all && _vmname=$(sed 's/"//g' $resf)
		[[ -z "$_vmname" ]] && { return; }
	}

	local port=$(_vmvncport $_vmname)
	if [[ -n "${port}" ]]; then
		if [[ -z "${VNCPUTS}" && -z "${VNCGET}" && -z "${VNCGETSC}" ]]; then
			hnames=$(hostname -A 2>/dev/null); test -z "$hnames" && hnames=$(hostname)
			h=0
			for _host in $(echo "${hnames}"|xargs -n 1|sort -u); do
				_host=${_host%.localdomain}
				ping -c 2 ${_host} &>/dev/null || continue
				let h++; echo ${_host}:$port
			done
			[[ $h = 0 ]] && echo localhost:$port
			return
		fi

		if [[ -n "${VNCPUTS}" ]]; then
			vncput localhost::$port "${VNCPUTS[@]}"
			echo "[vncput@$_vmname]> ${VNCPUTS[*]}"
		fi
		if [[ -n "${VNCGETSC}" ]]; then
			[[ -t 1 || ! -p /dev/stdout ]] && echo "[vncgetsc@$_vmname]:" >&2
			vncgetsc localhost::$port $_vmname
		fi
		if [[ -n "${VNCGET}" ]]; then
			[[ -t 1 || ! -p /dev/stdout ]] && echo "[vncget@$_vmname]:" >&2
			vncget localhost::$port ${OCR_TOOL}
		fi
	fi
}

vmxml() {
	local _vmname=$(vmname_extract -all "$1")
	[[ -z "$_vmname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogradiolist vm-dumpxml $resf all && _vmname=$(sed 's/"//g' $resf)
		[[ -z "$_vmname" ]] && { return; }
	}

	virsh dumpxml "$_vmname"
}

vmedit() {
	local _vmname=$(vmname_extract -all "$1")
	[[ -z "$_vmname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogradiolist vm-edit $resf all && _vmname=$(sed 's/"//g' $resf)
		[[ -z "$_vmname" ]] && { return; }
	}

	grep -q export.EDITOR= ~/.bashrc /etc/bashrc || export EDITOR=$(command -v vim||command -v vi)
	virsh edit "$_vmname"
}

port_available() {
	nc $(grep -q -- '-z\>' < <(nc -h 2>&1) && echo -z) $1 $2 </dev/null &>/dev/null
}

vmreboot() {
	local _vmname=$(vmname_extract -all "$1")
	[[ -z "$_vmname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogradiolist vm-reboot $resf all && _vmname=$(sed 's/"//g' $resf)
		[[ -z "$_vmname" ]] && { return; }
	}

	set -- $(vmname_extract "$@")
	for vm; do
		virsh destroy "$vm" 2>/dev/null
		virsh start "$vm"
	done

	[[ "$WAIT" = yes ]] && {
		for vm; do
			echo -e "{VM:INFO} waiting [$vm] restart finish ..."
			read _addr < <(vmifaddr "$vm")
			until port_available ${_addr} 22; do sleep 1; done
		done
	}
}

vmstop() {
	local _vmname=$(vmname_extract "$1")
	[[ -z "$_vmname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogchecklist vm-shutdown $resf all && vmList=$(< $resf)
		[[ -z "$vmList" ]] && { return; }
		eval set $vmList
	}

	set -- $(vmname_extract "$@")
	for vm; do
		virsh destroy "$vm"
	done
}

vmstart() {
	local _vmname=$(vmname_extract -all "$1")
	[[ -z "$_vmname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogchecklist vm-start $resf all && vmList=$(< $resf)
		[[ -z "$vmList" ]] && { return; }
		eval set $vmList
	}
 
	set -- $(vmname_extract -all "$@")
	for vm; do
		virsh start "$vm"
	done
}

vmautostart() {
	local _vmname=$(vmname_extract -all "$1")
	[[ -z "$_vmname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogchecklist vm-start $resf all && vmList=$(< $resf)
		[[ -z "$vmList" ]] && { return; }
		eval set $vmList
	}
 
	set -- $(vmname_extract -all "$@")
	for vm; do
		virsh autostart $AutoStartOpt "$vm"
	done
}
vmnoautostart() {
	AutoStartOpt=--disable vmautostart "$@"
}

vmstat() {
	local _vmname=$(vmname_extract -all "$1")
	[[ -z "$_vmname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogchecklist vm-stat $resf all && vmList=$(< $resf)
		[[ -z "$vmList" ]] && { return; }
		eval set $vmList
	}

	set -- $(vmname_extract -all "$@")
	for vm; do
		cvirsh domstate "$vm"
	done
}

vmclone() {
	[[ "$1" = /a ]] && {
		shift
		local APPEND=yes
	}

	is_invalid_vmname() {
		local nvmname=$1
		grep -E --color=always "[][~\!@#$^&()=,\":;{}|<>'\` ]" <<<"$nvmname"
	}

	echo -e "{VM:INFO} checking source and destination VM status ..."
	local srcname=$(vmname_extract -all "$1"|head -1)
	local dstname=$2
	[[ -z "$srcname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogradiolist vm-clone $resf all && srcname=$(sed 's/"//g' $resf)
		[[ -z "$srcname" ]] && {
			return;
		}
	}
	if [[ -z "$dstname" ]]; then
		dstname=${srcname}-clone-$$
	else
		#verify invalid charactors
		[[ "$APPEND" = yes ]] && dstname=${srcname}-${dstname}
	fi
	is_invalid_vmname "$dstname" && return 1
	virsh desc $dstname &>/dev/null && {
		echo -e "{VM:WARN} Guest $dstname has been there ..." >&2
		return 1
	}

	#get src vm path
	srcpath=$(vmhomedir $srcname 2>/dev/null|head -n1)
	[[ ! -r "${srcpath}" ]] && {
		echo "homedir($srcname): $srcpath"
		echo -e "{VM:WARN} Guest homedir is not readable for current user($(whoami)) ..." >&2
		return 1
	}
	[[ ! -f ${srcpath}/.kiss-vm || ${srcpath##*/} != ${srcname} ]] && {
		echo -e "{VM:WARN} seems $srcname was not created by kiss-vm, can not use vm-clone; please use virt-clone instead ..." >&2
		return 1
	}
	[[ ! -r ${srcpath}/.kiss-vm ]] && {
		vmhomedir $srcname
		echo -e "{VM:WARN} Guest $srcname is not readable for current user($(whoami)) ..." >&2
		return 1
	}

	#virsh suspend "$srcname"
	echo -e "{VM:INFO} stoping source VM '${srcname}' ..."
	virsh destroy "$srcname" &>/dev/null
	[[ "$(vmstat $srcname)" = running* ]] && {
		echo -e "{VM:WARN} Guest $srcname is still running, please stop it before clone ..." >&2
		return 1
	}

	# do clone
	echo -e "{VM:INFO} cloning $srcname to $dstname ..."
	local distron=$(awk -F/ '{print $(NF-1)}' <<<"${srcpath}")
	local dstpath=$VMSHOME/$distron/$dstname
	create_vmhome $dstpath
	rm -f $dstpath/*
	if [[ "$VMSHARE" != yes ]]; then
		setfacl -d -mg::--- -mo::--- $dstpath
	fi
	chcon --reference=${srcpath} $dstpath 2>/dev/null
	run -as=$VMUSER touch $dstpath/.kiss-vm

	fileopts=$(_vmblklist $srcname|sed -rn '/( -|\.iso)$/!{ s|^.* | --file |;'"s|$srcpath|$dstpath|;s%/${srcname}([^/]+)\$%/${dstname}\1%;"' p}'|xargs)
	run -debug -as=$VMUSER bash -c "virt-clone -o ${srcname} --name ${dstname} $fileopts \
		--check path_exists=off --check disk_size=off \
		--print-xml >$dstpath/${dstname}.xml"
	[[ -s $dstpath/${dstname}.xml ]] || return 1
	sed -i "s|$srcpath|$dstpath|" $dstpath/${dstname}.xml
	#Note: https://www.reddit.com/r/archlinux/comments/obn999/ownership_of_qcow2_images_created_by_virtmanager/
	#^^^^ why don't use virt-clone directly

	#copy file
	for f in ${srcpath}/*; do
		fname=${f##*/}
		df=$dstpath/$fname
		[[ "${fname}" = nohup.log ]] && continue
		if [[ "${fname}" = ${srcname}[-.]* ]]; then
			dfname=${fname/$srcname/$dstname}
			df="$dstpath/${dfname}"
			sed -i "s|/$fname|/$dfname|g" $dstpath/${dstname}.xml
		fi
		run -debug cp -p --sparse=always --preserve=all "$f" "$df"
		#if the cp --preserve=context does not work, use:
		#run -debug chcon --reference="$f" "$df" 2>/dev/null
	done

	#virt-clone get wrong nvram path/filename, fix it.
	if grep -q "<nvram>$dstpath/" $dstpath/${dstname}.xml; then
		nvramline=$(virsh dumpxml "$srcname"|sed -n "/<nvram>/{s#$srcpath#$dstpath#; p}")
		sed -i "/<nvram>/s#^.*\$#${nvramline}#" $dstpath/${dstname}.xml
	fi

	if [[ $(id -u) = 0 ]]; then
		chown $VMUSER:$(id -g -u $VMUSER) -R $dstpath
	fi
	run -debug -as=$VMUSER virsh define $dstpath/${dstname}.xml
	vmhomedir ${dstname}

		#--enable customize,user-account,ssh-hostkeys,net-hostname,net-hwaddr,machine-id \
	LIBGUESTFS_BACKEND=direct run -debug virt-sysprep -d ${dstname} \
		--enable customize,user-account,net-hostname,net-hwaddr,machine-id \
		--hostname $dstname \
		--remove-user-accounts bar \
		--run-command "ls -l"
	run -debug -as=$VMUSER virsh start $dstname

	#virsh resume "$srcname"
	#virsh start "$srcname"
}

sshtest() {
	local target=$1
	local sshOpts=${2:--oUserKnownHostsFile=/dev/null -oStrictHostKeyChecking=no -oGSSAPIAuthentication=no $sshKeyOpts}
	local result=255
	local tmpf=${RuntimeTmp}/_sshtest
	local KexAlgorithmsOpt=
	[[ -z "${RuntimeTmp}" ]] && tmpf=$(mktemp)
	local _cmd=  #work-around for avoiding hang while test against windows openssh-server
	[[ "${target,,}" = administrator@* ]] && _cmd=exit
	LANG=C /usr/bin/ssh -v -n -o Batchmode=yes $sshOpts $target $_cmd &>$tmpf; sshrc=$?
	[[ "$DEBUG" = yes ]] && {
		echo "[sshtest:debug] sshrc=$sshrc" >&2
		echo -e "\033[32m$(tail -n 20 $tmpf)\033[0m" >&2
	}
	if [[ $sshrc = 0 ]]; then
		result=0  #can login or run command without password
	elif grep -iq '^Bytes per second:' $tmpf; then
		result=0  #freebsd "publickey" login
	elif grep -v ^debug1: $tmpf|grep -iq "Permission denied (.*password.*)"; then
		result=1  #can login or run command with password
	elif grep -iq "no matching key exchange method found. Their offer:" $tmpf; then
		local KexAlgorithmsOpt=-oKexAlgorithms=+$(sed -n '/^.*Their offer: /{s///;s/\r//;p}' $tmpf)
		if [[ "$sshOpts" != *$KexAlgorithmsOpt ]]; then
			sshOpts+=" $KexAlgorithmsOpt"
			sshtest $target "$sshOpts"
			result=$?
		else
			result=2  #can not connect to ssh
		fi
	elif grep -iq "no matching host key type found. Their offer: ssh-rsa" $tmpf; then
		sshtest $target "-oHostKeyAlgorithms=+ssh-rsa -oPubkeyAcceptedKeyTypes=+ssh-rsa $sshOpts"
		result=$?
	fi
	[[ -z "${RuntimeTmp}" ]] && rm -f $tmpf

	[[ -z "$KexAlgorithmsOpt" ]] && echo "$sshOpts"
	return $result
}

vmcopyto() {
	[[ "$#" -lt 3 ]] && {
		echo "Usage: vm cpto vmname <src files/dirs ...> <dst dir in vm>"
		return 1
	}
	local U=root _vmname= _pat="$1"
	shift
	_vmname=$(vmname_extract -all "${_pat#*@}"|head -1)
	local _addr=
	local dstdir=${@: -1}
	local srcarray=("${@:1: $#-1}")

	read _addr < <(vmifaddr "$_vmname")
	port_available $_addr 22 || {
		echo -e "{VM:ERR} port $_vmname:22 is not available" >&2
		return 1
	}

	local sshstat=unavailable
	local sshOpts="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o GSSAPIAuthentication=no -o LogLevel=ERROR $sshKeyOpts"
	vmhomedir $_vmname | grep -E -q -i -e windows && {
		U=Administrator; defaultPasswd=$defaultWindowsPasswd;
	}
	[[ "$_pat" = *@* ]] && read U _pat <<<"${_pat/@/ }"
	[[ "$U" = *[:,]* ]] && read U defaultPasswd <<<"${U/[:,]/ }"
	[[ -n "$CM_USER" ]] && { U="$CM_USER"; }
	[[ -n "$CM_PASSWD" ]] && { defaultPasswd="$CM_PASSWD"; }

	sshOpts=$(sshtest $U@$_addr "$sshOpts")
	case $? in 0) sshstat=yes;; 1) sshstat=passwd;; esac
	[[ "$VERBOSE" -gt 0 && $sshstat != unavailable ]] && {
		echo -e "\E[01;36m[HOST]> scp \$sshOpts -r ${srcarray[@]} $U@${_addr}:$dstdir/.\E[0m" >&2
	}
	if [[ $sshstat = yes ]]; then
		scp $sshOpts -r "${srcarray[@]}" $U@${_addr}:$dstdir/.
		rc=$?
		[[ $rc = 0 ]] && {
			flist=()
			for f in "${srcarray[@]}"; do f=${f%/}; flist+=("$dstdir/${f##*/}"); done
			if [[ "$U" = Administrator ]]; then
				/usr/bin/ssh $sshOpts $U@${_addr} dir "${flist[@]}"
			else
				/usr/bin/ssh $sshOpts $U@${_addr} ls -ld "${flist[@]}"
			fi
		}
	elif [[ $sshstat = passwd ]]; then
		expect <(cat <<-EOF
		set timeout 120
		spawn {*}\${argv}
		expect {
			"password:" { send "$defaultPasswd\r"; exp_continue }
			"Password for" { send "$defaultPasswd\r"; exp_continue }
			eof
		}
		foreach {pid spawnid os_error_flag value} [wait] break
		exit \$value
		EOF
		) scp $sshOpts -r "${srcarray[@]}" $U@${_addr}:$dstdir/.
		rc=$?
	else
		echo -e "{VM:WARN} /usr/bin/ssh $_vmname is not available ..." >&2
		rc=1
	fi
	return $rc
}

vmcopyfrom() {
	[[ "$#" -lt 3 ]] && {
		echo "Usage: vm cpfrom vmname <file/dir> <dst dir>"
		return 1
	}
	local U=root _vmname= _pat="$1"
	shift
	_vmname=$(vmname_extract -all "${_pat#*@}"|head -1)
	local src=${1%/}
	local dstf=${2}
	[[ -d "$dstf" ]] && dstf=$(readlink -f $dstf)

	read _addr < <(vmifaddr "$_vmname")
	port_available $_addr 22 || {
		echo -e "{VM:ERR} port $_vmname:22 is not available" >&2
		return 1
	}

	local sshstat=unavailable
	local sshOpts="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o GSSAPIAuthentication=no -o LogLevel=ERROR $sshKeyOpts"
	vmhomedir $_vmname | grep -q -i windows && {
		U=Administrator; defaultPasswd=$defaultWindowsPasswd;
	}
	[[ "$_pat" = *@* ]] && read U _pat <<<"${_pat/@/ }"
	[[ "$U" = *[:,]* ]] && read U defaultPasswd <<<"${U/[:,]/ }"
	[[ -n "$CM_USER" ]] && { U="$CM_USER"; }
	[[ -n "$CM_PASSWD" ]] && { defaultPasswd="$CM_PASSWD"; }

	sshOpts=$(sshtest $U@$_addr "$sshOpts")
	case $? in 0) sshstat=yes;; 1) sshstat=passwd;; esac
	[[ "$VERBOSE" -gt 0 && $sshstat != unavailable ]] && {
		echo -e "\E[01;36m[HOST]> scp \$sshOpts -r $U@${_addr}:$src $dstf\E[0m" >&2
	}
	if [[ $sshstat = yes ]]; then
		scp $sshOpts -r $U@${_addr}:$src $dstf
		rc=$?
	elif [[ $sshstat = passwd ]]; then
		expect <(cat <<-EOF
		set timeout 120
		spawn {*}\${argv}
		expect {
			"password:" { send "$defaultPasswd\r"; exp_continue }
			"Password for" { send "$defaultPasswd\r"; exp_continue }
			eof
		}
		foreach {pid spawnid os_error_flag value} [wait] break
		exit \$value
		EOF
		) scp $sshOpts -r $U@${_addr}:$src $dstf
		rc=$?
	else
		echo -e "{VM:WARN} /usr/bin/ssh $_vmname is not available ..." >&2
		rc=1
	fi

	[[ $rc = 0 ]] && {
		if [[ -f "$dstf" ]]; then
			ls -l $dstf
		else
			ls -l -d ${dstf}/${src##*/}
		fi
	}

	return $rc
}

vmport_available() {
	local _vmname=$(vmname_extract -all "$1")
	local _port=${2:-22}
	local wait_opt=
	[[ -z "$_vmname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogradiolist vm-console $resf && _vmname=$(sed 's/"//g' $resf)
		[[ -z "$_vmname" ]] && { return; }
	}
	local _addr=$(vm ifaddr "$_vmname"|head -1)
	if [[ "$WAIT" = yes ]]; then
		while [[ -z "$_addr" ]]; do
			sleep 8
			_addr=$(vm ifaddr "$_vmname"|head -1)
		done
		port-available.sh "$_addr" $_port -w
	else
		port-available.sh "$_addr" $_port
	fi
	return $?
}

vmconsole() {
	local _vmname=$(vmname_extract -all "$1")
	shift
	[[ -z "$_vmname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogradiolist vm-console $resf && _vmname=$(sed 's/"//g' $resf)
		[[ -z "$_vmname" ]] && { return; }
	}
	virsh console ${FORCE:+--force} "$_vmname"
	return $?
}

vmqmp() {
	local _vmname=$(vmname_extract -all "$1")
	shift
	[[ -z "$_vmname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogradiolist vm-console $resf && _vmname=$(sed 's/"//g' $resf)
		[[ -z "$_vmname" ]] && { return; }
	}
	local homedir=$(vm homedir $_vmname |& head -1)
	local vmtmp=$homedir/tmp
	if [[ ! -d "$vmtmp" ]]; then
		echo -e "{VM:WARN} no qmp socket found on $_vmname" >&2
		return 2
	fi
	local qmpsockf=$vmtmp/qmp.socket
	if [[ -f $vmtmp/qmp.tcp ]]; then
		qmparg=$(sed -r 's/^(tcp)://' $vmtmp/qmp.tcp)
	elif [[ -f $vmtmp/qmp.unix ]]; then
		qmparg=$(sed -r 's/^(unix)://' $vmtmp/qmp.unix)
	elif [[ -S $qmpsockf ]]; then
		qmparg=$qmpsockf
	else
		echo -e "{VM:WARN} No qmp socket found on $_vmname" >&2
		return 2
	fi

	if command -v qmp-shell &>/dev/null; then
		run -debug qmp-shell -p -v $qmparg
	else
		[[ -S "$qmparg" ]] && ncOpt=-U
		run -debug nc $ncOpt $qmparg
	fi
	return $?
}
vmmonitor() {
	local _vmname=$(vmname_extract -all "$1")
	shift
	[[ -z "$_vmname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogradiolist vm-console $resf && _vmname=$(sed 's/"//g' $resf)
		[[ -z "$_vmname" ]] && { return; }
	}
	local homedir=$(vm homedir $_vmname |& head -1)
	local vmtmp=$homedir/tmp
	if [[ ! -d "$vmtmp" ]]; then
		echo -e "{VM:WARN} no monitor socket found on $_vmname" >&2
		return 2
	fi
	local monsockf=$vmtmp/monitor.socket
	if [[ -f $vmtmp/monitor.tcp ]]; then
		monarg=$(sed -r 's/^(tcp)://' $vmtmp/monitor.tcp)
	elif [[ -f $vmtmp/monitor.unix ]]; then
		monarg=$(sed -r 's/^(unix)://' $vmtmp/monitor.unix)
	elif [[ -S $monsockf ]]; then
		monarg=$monsockf
	else
		echo -e "{VM:WARN} No monitor socket found on $_vmname" >&2
		return 2
	fi

	[[ -S "$monarg" ]] && ncOpt=-U
	run -debug nc $ncOpt $monarg
	return $?
}

vmlogin() {
	local U=root _vmname= _pat="$1"
	shift
	_vmname=$(vmname_extract -all "${_pat#*@}"|head -1)
	[[ -z "$_vmname" ]] && {
		resf=$RuntimeTmp/vmlist
		vmdialogradiolist vm-login $resf && _vmname=$(sed 's/"//g' $resf)
		[[ -z "$_vmname" ]] && { return; }
	}
	[[ "$(vmstat $_vmname)" = running* ]] || {
		echo -e "{VM:WARN} $_vmname has not been running or not exist" >&2
		return 1
	}
	vmhomedir $_vmname 2>/dev/null | grep -q -i windows && {
		U=Administrator; defaultPasswd=$defaultWindowsPasswd;
	}

	[[ "$_pat" = *@* ]] && read U _pat <<<"${_pat/@/ }"
	[[ "$U" = *[:,]* ]] && read U defaultPasswd <<<"${U/[:,]/ }"

	[[ -n "$CM_USER" ]] && { U="$CM_USER"; }
	[[ -n "$CM_PASSWD" ]] && { defaultPasswd="$CM_PASSWD"; }

	local sshCommand=
	if [[ "${EXEC}" = yes ]]; then
		sshCommand=$(getReusableCommandLine "$@")
		[[ $# = 0 ]] && set "exit 0";
		[[ "$VERBOSE" -gt 0 ]] &&
			echo -e "\E[01;36m[$U@$_vmname]> ${sshCommand//\\/\\\\}\E[0m" >&2
	else
		[[ -n "$1" ]] && {
			U=$1; shift;
			[[ -n "$1" ]] && { defaultPasswd=$1; shift; }
		}
	fi

	#sometimes there's bug in libnss. get more than one addr but some one
	#of them does not exist. detect and ignore it/them
	addrs=$(vmifaddr "$_vmname")
	[[ -z "$addrs" ]] && {
		if [[ "${EXEC}" = yes ]]; then
			echo -e "{VM:WARN} can not get ip info of $_vmname ..." >&2
			return 107
		else
			echo -e "{VM:WARN} can not get ip info of $_vmname, try login with console ..." >&2
			virsh console "$_vmname"
			return $?
		fi
	}

	local sshOpts="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o GSSAPIAuthentication=no $sshKeyOpts"
	echo -n "$sshCommand" >$RuntimeTmp/sshcmd
	for addr in $addrs; do
		[[ "$DEBUG" = yes ]] &&
			echo -e "\E[01;36m[vmlogin:debug] detect port ${addr}:22 ...\E[0m" >&2

		port_available $addr 22 || {
			echo -e "{VM:WARN} port $addr:22 is not available" >&2
			continue
		}

		[[ "$DEBUG" = yes ]] &&
			echo -e "\E[01;36m[vmlogin:debug] port ${addr}:22 available ...\E[0m" >&2

		sshstat=unavailable
		sshOpts=$(sshtest $U@$addr "$sshOpts")
		case $? in 0) sshstat=yes;; 1) sshstat=passwd;; esac
		[[ "${EXEC}" = yes ]] && sshOpts+=" -n"
		if [[ $sshstat = yes ]]; then
			/usr/bin/ssh $sshOpts $U@$addr "${sshCommand}"
			rc=$?
		elif [[ $sshstat = passwd ]]; then
			expect <(cat <<-EOF
			set timeout 120
			set sshcmd [exec cat $RuntimeTmp/sshcmd]
			log_user 0
			spawn /usr/bin/ssh $sshOpts $U@$addr \$sshcmd
			log_user 1
			if {\$argc == 0 || \$sshcmd == ""} {
				expect {
				"\[Pp]assword:" { send "$defaultPasswd\r"; exp_continue }
				"Password for" { send "$defaultPasswd\r"; exp_continue }
				"*# " { send "\r"; interact }
				"*$ " { send "\r"; interact }
				"PS C*> " { send "\r"; interact }
				}
			} else {
				set timeout -1
				expect {
				"\[Pp]assword:" { send "$defaultPasswd\r"; exp_continue }
				"Password for" { send "$defaultPasswd\r"; exp_continue }
				eof
				}
			}
			foreach {pid spawnid os_error_flag value} [wait] break
			exit \$value
			EOF
			) "$@"
			rc=$?
		else
			if [[ "${EXEC}" = yes ]]; then
				echo -e "{VM:ERR} /usr/bin/ssh $sshOpts $U@$addr fail, exit." >&2
				return 1
			else
				echo -e "{VM:WARN} /usr/bin/ssh $sshOpts $U@$addr fail, try login with console ..." >&2
				virsh console "$_vmname"
				rc=$?
			fi
		fi

		faillog() { echo -e "\033[41m{TEST:FAIL} $*\033[0m" >&2; }
		[[ -n "$expectedrc" ]] && {
			[[ " ${expectedrc[@]} " != *" $rc "* ]] && {
				faillog "return code: expect $expectedRC, but got $rc"
			}
		}

		return $rc
	done
}

vmadd_iso() {
	local vmname=$(vmname_extract -all "$1")
	local isof=$2
	local homedir=$(vm homedir $vmname |& head -1)
	if [[ ! -d "$homedir" ]]; then
		echo -e "{VM:ERROR} empty or invalide vm-homedir($homedir)" >&2
		return
	fi
	if [[ -f "$isof" ]]; then
		cp "$isof" $homedir/.
		isof=$homedir/${isof##*/}
	else
		echo -e "{VM:WARN} iso file '$isof' not exist ..." >&2
		return
	fi

	local xmls=$(virsh dumpxml $vmname; virsh dumpxml --inactive $vmname)
	for _target in sd{c..z}; do echo "$xmls"|grep -q -w $_target || break; done
	run -debug virsh attach-disk $vmname "$isof" $_target --targetbus=sata --type cdrom --mode readonly
	if [[ $? != 0 ]]; then
		local _type= _dev= target= _image=
		read _type _dev target _image < <(_vmblklist $vmname | awk '$2=="cdrom"')
		echo -e "{VM:INFO} retry->push iso into existed cdrom: $target"
		run -debug virsh attach-disk $vmname "$isof" $target --type cdrom --mode readonly
	fi
}

vmadd_disk() {
	local vmname=$(vmname_extract -all "$1")
	local diskf=$2
	local homedir=$(vm homedir $vmname |& head -1)
	if [[ ! -d "$homedir" ]]; then
		echo -e "{VM:ERROR} empty or invalide vm-homedir($homedir)" >&2
		return 1
	fi
	local subdrv_opt=
	local tgtbus_opt=
	local diskprefix=sd

	read diskf _attrs <<< "${diskf//,/ }"
	[[ "${size: -1}" = [0-9] ]] && size+=G
	eval "$_attrs"  #drv=qcow2,raw,... bus=virtio,scsi,sata,...
	[[ -n "$drv" ]] && subdrv_opt=--subdriver=$drv
	[[ -n "$bus" ]] && tgtbus_opt=--targetbus=$bus

	if [[ -f "$diskf" ]]; then
		cp "$diskf" $homedir/.
		diskf=$homedir/${diskf##*/}
		LANG=C file "$diskf"|grep -iq "QEMU QCOW Image" && subdrv_opt=--subdriver=qcow2
	elif [[ -b "$diskf" ]]; then
		:
	elif [[ ! -e "$diskf" && "$diskf" != */* ]]; then
		diskf="$homedir/$diskf"
		if [[ -f "$diskf" ]]; then
			{ echo -e "{VM:WARN} '$diskf' already exist." >&2; : return; }
		else
			qemu-img create -f qcow2 "${diskf}" ${size:-80G}
		fi
		subdrv_opt=${subdrv_opt:---subdriver=qcow2}
	fi

	if [[ ! -e "$diskf" ]]; then
		echo -e "{VM:ERROR} file '$diskf' not exist" >&2
		return 2
	fi

	[[ "$tgtbus_opt" = *virtio* ]] && diskprefix=vd
	local xmls=$(virsh dumpxml $vmname; virsh dumpxml --inactive $vmname)
	for _target in ${diskprefix}{a..z}; do echo "$xmls"|grep -q -w $_target || break; done
	run -debug virsh attach-disk $vmname $subdrv_opt $tgtbus_opt "$diskf" $_target
}

vmadd_if() {
	local vmname=$(vmname_extract -all "$1")
	local network=$2
	shift 2

	run -debug virsh attach-interface --type network --domain $vmname --source $network \
		--model virtio --config --live "$@"
}

vmadd_if_bridge() {
	local vmname=$(vmname_extract -all "$1")
	local brg=$2
	shift 2

	run -debug virsh attach-interface --type bridge --domain $vmname --source $brg \
		--model virtio --config --live "$@"
}

vmadd_if_direct() {
	local vmname=$(vmname_extract -all "$1")
	local srcif=${srcif:-$(get-default-if.sh)}
	shift

	run -debug virsh attach-interface --type direct --domain $vmname --source $srcif \
		--model virtio --config --live "$@"
}

nic2pcislot() {
	local nic=$1
	local eventf=/sys/class/net/$nic/device/uevent
	if [[ -e $eventf ]]; then
		awk -F= '/PCI_SLOT_NAME/{print "pci_" $2}' $eventf | sed 's/[:.]/_/g'
	fi
}

vmadd_if_passthr() {
	local vmname=$(vmname_extract -all "$1")
	local _hostif=$2
	local pci_addr=$2
	local eventf=/sys/class/net/$_hostif/device/uevent
	if [[ -e $eventf ]]; then
		pci_addr=$(nic2pcislot $_hostif)
	fi
	shift 2

	run -debug virsh attach-interface --type hostdev --domain $vmname --source ${pci_addr#pci_} \
		--config --live "$@"
}

vmpassthr() {
	local vmname=$(vmname_extract -all "$1")
	local devaddr=$2
	#fixme not tested
	#virt-xml $vmname --update --add-device --hostdev $devaddr
}

vmexec() { EXEC=yes vmlogin "${@}"; }
vmlist() {
	[[ $# = 0 || "$*" = / ]] && set /all
	[[ "$*" = */help* ]] && {
		virsh list --help | awk '$1 ~ "^--" {print gensub("--", "/", 1)}'
		return
	}
	virsh list "${@/\//--}"
}

netls() { virsh net-list; }
netcreate() {
	local netname=
	local brname=
	local subnet=
	local forward=nat
	local domainname=

	Usage() {
		cat <<-U
		Example:
		  vm netcreat netname=net10 brname=virbr10 subnet=10  #means 192.168.10.0
		  vm netcreat netname=net10 brname=virbr10 subnet=172.25.252.0 [forward=nat]
		  vm netcreat netname=net10 brname=virbr10 subnet=172.25.252.0 [forward=nat] [tftproot=/path] [bootpfile=] [domain=]
		  vm netcreat netname=net10 brname=virbr10 subnet=10.10.100.0 [dhcphosts=10.10.100.11@02:00:aa:0a:01:01,10.10.100.12@02:00:aa:0a:01:02] [...]
		U
	}
	[[ $# = 0 ]] && { virsh net-list; Usage >&2; return; }
	for opt; do [[ "$opt" =~ ^(netname|brname|subnet|forward|tftproot|bootpfile|domain|dhcphosts)=.* ]] || continue; eval "$opt"; done
	[[ -z "$netname" || -z "$brname" ]] && { Usage >&2; return 1; }
	domainname="${domain:-${netname}.kissvm.net}"

	#https://libvirt.org/formatnetwork.html
	[[ -n "$forward" && "$forward" != no ]] && {
		forwardNode="<forward mode=\"$forward\"/>"
		[[ "$forward" = nat ]] && forwardNode="<forward mode=\"$forward\" >
		    <nat>
		      <port start='1024' end='65535'/>
		    </nat>
		  </forward>"
	}
	[[ -n "$tftproot" ]] && tftpNode="<tftp root='$tftproot'/>"
	[[ -n "$bootpfile" ]] && bootpNode="<bootp file='$bootpfile'/>"
	[[ -n "$domainname" ]] && domainNode="<domain name='$domainname' localOnly='yes'/>"
	if [[ -n "$subnet" ]]; then
		netmask=255.255.255.0
		rx='([1-9]?[0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])'
		if [[ "$subnet" =~ ^${rx}$ ]]; then
			subnet=192.168.${subnet}
		elif [[ "$subnet" =~ ^$rx\.$rx\.$rx$ ]]; then
			subnet=${subnet}
		elif [[ "$subnet" =~ ^$rx\.$rx\.$rx\.$rx$ ]]; then
			subnet=${subnet%.*}
		else
			echo "{VM:netcreate} invalid subnet addr: $subnet" >&2
			Usage >&2
			return 1
		fi

		gatewayaddr="${subnet}.254"
		range_start="${subnet}.64"
		range_end="${subnet}.250"

		ipNode="<ip address=\"${subnet}.1\" netmask=\"$netmask\" >
		    $tftpNode
		    <dhcp>
		      <range start=\"${range_start}\" end=\"${range_end}\"/>
		      $bootpNode
		      $(for macip in ${dhcphosts//,/ }; do read mac ip <<<${macip/@/ }; echo "<host mac=\"$mac\" ip=\"$ip\"/>"; done)
		    </dhcp>
		  </ip>"
	fi

	_netinfo=$(LANG=C virsh net-info -- "$netname" 2>/dev/null) && {
		echo "{VM:WARN} Virt network $netname has been there." >&2
		grep -q ^Active:.*yes <<<"$_netinfo" || {
			virsh net-start "$netname"
		}
		return
	}

	stpAttr='stp="off"'
	macTableManagerAttr='macTableManager="libvirt"'
	virsh net-define --file <(
		cat <<-NET
		<network>
		  <name>$netname</name>
		  <bridge name="$brname" $stpAttr $macTableManagerAttr/>
		  $forwardNode
		  $domainNode
		  $ipNode
		</network>
		NET
	)
	virsh net-start $netname
	virsh net-autostart $netname
}
netinfo() {
	for net; do
		virsh net-info -- $net || continue
		virsh net-dumpxml -- $net
	done
}
netstart() {
	for net; do
		virsh net-start -- $net
	done
}
netdelete() {
	echo -e "\n{VM:INFO} => delete virtual net: $@ .."
	for net; do
		virsh net-destroy -- $net
		virsh net-undefine -- $net
	done
}

vercmp() {
	usage() {
		echo "usage: vercmp  <ver1> < =  | '>' | '<' | '>=' | '<=' >  <ver2>" >&2
		echo "       vercmp  <ver1> < eq | gt  | lt  |  ge  |  le  >  <ver2>" >&2
		echo "       vercmp  <ver1> < match >  <'pattern'>" >&2
	}

	[ $# != 3 ] && {
		usage
		return 1
	}
	vl=$1
	cmpType=$2
	vr=$3
	res=1

	[ "$vl" = "$vr" ] && eq=1
	vmax=$(echo -e "$vl\n$vr" | sort -V | tail -n 1)

	case "$cmpType" in
	=|eq) [ "$eq" = 1 ] && res=0;;
	\>|gt) [ "$eq" != 1 -a "$vl" = "$vmax" ] && res=0;;
	\<|lt) [ "$eq" != 1 -a "$vr" = "$vmax" ] && res=0;;
	\>=|ge) [ "$vl" = "$vmax" ] && res=0;;
	\<=|le) [ "$vr" = "$vmax" ] && res=0;;
	*) echo "$vl" | grep -E -q "$vr"; res=$?;;
	esac

	return $res
}

curl_download() {
	local filename=$1
	local url=$2
	shift 2;

	local curlopts="-f -L -k"
	local header=
	local fsizer=1
	local fsizel=0
	local rc=

	[[ -z "$filename" || -z "$url" ]] && {
		echo "Usage: curl_download <filename> <url> [curl options]" >&2
		return 1
	}

	header=$(curl -L -I -s $url|sed 's/\r//')
	fsizer=$(echo "$header"|awk -v IGNORECASE=1 '/Content-Length:/ {print $2; exit}')
	if echo "$header"|grep -iq 'Accept-Ranges: bytes'; then
		curlopts+=' --continue-at -'
	fi

	echo "{VM:INFO} run: curl -o $filename \$url $curlopts $curlOpt $@"
	run -as=$VMUSER curl -o $filename $url $curlopts $curlOpt "$@"
	rc=$?
	if [[ $rc != 0 && -s $filename ]]; then
		fsizel=$(stat --printf %s $filename)
		if [[ $fsizer -le $fsizel ]]; then
			echo "{VM:INFO} *** '$filename' already exist $fsizel/$fsizer"
			rc=0
		fi
	fi

	return $rc
}
curl_download_x() { until curl_download "$@"; do sleep 1; done; }

#-------------------------------------------------------------------------------

is_slackware() { grep -iq slackware /etc/os-release; }
sbopkg_install() {
	local pkg=$1
	sudo /usr/sbin/sqg -p $pkg
	yes $'Q\nY\nP\nC' | sudo /usr/sbin/sbopkg -B -i $pkg
}
install_requires() {
	. /etc/os-release
	OS=$NAME

	local pkglist=
	local recommend_pkglist=

	echo -e "{VM:INFO} checking libvirtd service and related packages ..."
	case ${OS,,} in
	slackware*)
		pkglist="python3 udisks2"
		for pkg in $pkglist; do
			sudo /usr/sbin/slackpkg -batch=on -default_answer=y -orig_backups=off install $pkg
		done

		echo -e "{VM:INFO} install sbopkg ..."
		sbopkg-install.sh

		sbopkglist="qemu libvirt virt-manager virt-viewer ovmf"
		for pkg in $sbopkglist; do
			if ! ls /var/log/packages/${pkg}-[0-9]* 2>/dev/null; then
				sbopkg_install $pkg
			fi
		done
		;;
	fedora*|red?hat*|centos*|rocky*|alma*|anolis*)
		pkglist="bash-completion libvirt libvirt-client virt-install virt-viewer qemu-kvm expect nmap-ncat tmux libguestfs-tools-c libvirt-nss dialog qemu-img udisks2 genisoimage iptables-nft ipcalc"
		recommend_pkglist="swtpm-tools edk2-ovmf virtio-win python3-qemu-qmp"

		OSV=$(rpm -E %rhel)
		if ! grep -E -q '^!?epel' < <(yum repolist 2>/dev/null); then
			[[ "$OSV" != "%rhel" ]] && yum $yumOpt install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-${OSV}.noarch.rpm 2>/dev/null
			[[ "$OSV" -ge 9 ]] && { pkglist+=' kernel-modules-extra'; }
		fi
		rpm -q $pkglist || {
			sudo yum $yumOpt --setopt=strict=0 install -y $pkglist
		}
		rpm -q $recommend_pkglist || {
			sudo yum $yumOpt --setopt=strict=0 install -y $recommend_pkglist
		}

		#install virtio driver for Windows Guest
		#see: https://github.com/virtio-win/virtio-win-pkg-scripts/blob/master/README.md
		rpm -q virtio-win &>/dev/null || {
			sudo tmux new -s virtio-win-iso-install -d virtio-win-iso-install.sh
		}
		[[ "$OSV" = 7 && $HostARCH = x86_64 && "$(rpm -q tmux)" != tmux-2.6* ]] && {
			yum remove -y tmux; pkill tmux 2>/dev/null
			yum install -y ftp://ftp.pbone.net/mirror/ftp5.gwdg.de/pub/opensuse/repositories/home:/assmannst/CentOS_7/x86_64/tmux-2.6-3.1.x86_64.rpm;
		}
		;;
	debian*|ubuntu*)
		pkglist="bash-completion libnss-libvirt libvirt-clients libvirt-daemon libvirt-daemon-system dnsmasq qemu-kvm virtinst expect nmap tmux libguestfs-tools dialog qemu-utils udisks2 genisoimage nftables acl ipcalc-ng"
		recommend_pkglist="swtpm-tools ovmf"

		read -d . verx 2>/dev/null </etc/debian_version
		[[ "$verx" = 9 ]] && {
			sudo apt -y update; sudo apt -y upgrade
			sudo apt install -o APT::Install-Suggests=0 -o APT::Install-Recommends=0 -y busybox-static iptables ebtables
		}
		sudo apt install -o APT::Install-Suggests=0 -o APT::Install-Recommends=0 --ignore-missing -y $pkglist
		sudo apt install -o APT::Install-Suggests=0 -o APT::Install-Recommends=0 --ignore-missing -y $recommend_pkglist
		sudo tmux new -s virtio-win-iso-install -d virtio-win-iso-install.sh
		;;
	opensuse*|sles*)
		pkglist="bash-completion libvirt libvirt-client virt-install virt-viewer qemu-kvm expect netcat tmux libguestfs guestfs-tools libvirt-nss dialog qemu-tools udisks2 mkisofs iptables-nft ipcalc"
		recommend_pkglist="swtpm ovmf"

		sudo zypper in --no-recommends -y $pkglist
		sudo zypper in --no-recommends -y $recommend_pkglist
		sudo tmux new -s virtio-win-iso-install -d virtio-win-iso-install.sh
		;;
	arch?linux)
		pkglist="bash-completion libvirt dnsmasq virt-install virt-viewer qemu-full qemu-tools guestfs-tools inetutils expect gnu-netcat tmux dialog udisks2 cdrtools ipcalc swtpm edk2-ovmf"
		recommend_pkglist="iptables-nft"

		sudo pacman -Sy --noconfirm $pkglist
		#sudo pacman -Sy --noconfirm $recommend_pkglist
		sudo tmux new -s virtio-win-iso-install -d virtio-win-iso-install.sh
		;;
	*)
		: #fixme add more platform
		echo -e "{VM:WARN} kiss-vm doesn't supported this platform($OS)" >&2
		return 2
		;;
	esac
}

prepare_kiss_vm() {
	local force=$1
	local vmuser=${VMUSER}
	eval vmuserhome=~$vmuser
	if [[ -n "$force" ]]; then
		echo -e "{VM:INFO} force re-prepare kiss-vm env"
	else
		[[ ! -L ${oldperConfDir} && -d $oldperConfDir ]] && {
			mv -T $oldperConfDir $perConfDir;
			run -as=$vmuser touch $perConfDir/kiss-vm;
		}
		if [[ -f $perConfDir/kiss-vm ]]; then
			[[ "$ONLY_PREPARE" = yes ]] && echo -e "{VM:INFO} kiss-vm has been initialized."
			return 0
		fi
	fi

	echo -e "~~~~~~~~~~~~~~~~~~~~~~~~~~~~ prepare libvirt start ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
	test $(id -u) = 0 || { echo "{VM:Error} vm prepare need root permission, try: sudo $P prepare" >&2; exit 1; }

	#virt-filesystems, virt-make-fs always hang on 'Fedora Linux Asahi Remix'
	#here enable udisksctl for non-root user to avoid using virt-* tools that
	#required by create-vdisk.sh/mount-vdisk.sh
	grep -q Asahi /etc/os-release && enable-udisksctl-loop-setup-and-delete.sh

	#try disable ipv6
	try_disable_ipv6

	#install packages required by kiss-vm
	install_requires; [[ $? = 2 ]] && return 1
	{ QEMU_USER=qemu; { ! id ${QEMU_USER} &>/dev/null || id libvirt-qemu &>/dev/null; } && QEMU_USER=libvirt-qemu; }
	chown root:libvirt $varlib_dir
	chmod g+ws $varlib_dir

	#install packages(gm,gocr,vncdo) required by vnc -get -put --putln options
	echo -e "{VM:INFO} install gm gocr and vncdo ..."
	ggv-install.sh

	#install packages qemu-system-*
	qemu-system-archs-install.sh aarch64 s390x ppc riscv

	echo -e "{VM:INFO} configure libvirt-nss ..."
	grep -q '^hosts:.*libvirt libvirt_guest' /etc/nsswitch.conf || {
		echo -e "{*INFO*} you have not configure /etc/nsswitch.conf, trying sed ..."
		sed -ri '/^hosts:/s/files /&libvirt libvirt_guest /' /etc/nsswitch.conf
	}

	# start libvirt services ..."
	use_monolithic() {
		if ! grep -Fq "virtqemud.service" <(systemctl list-units -a --type service); then
			return 0
		elif systemctl is-enabled --quiet libvirtd; then
			return 0
		fi
		return 1
	}
	if use_monolithic; then
		echo -e "{VM:INFO} start libvirtd service:"
		test -x /etc/rc.d/rc.libvirt && /etc/rc.d/rc.libvirt start   #for Slackware
		if command -v systemctl >/dev/null; then
			systemctl is-enabled --quiet libvirtd || systemctl enable libvirtd
			systemctl is-active --quiet libvirtd || { systemctl start libvirtd; }
		fi

		virtdconf=/etc/libvirt/libvirtd.conf
		echo -e "{VM:INFO} confiure $virtdconf ..."
		sed -ri -e '/#unix_sock_group = "libvirt"/s/^#//' -e '/#unix_sock_rw_perms = "0770"/s/^#//' $virtdconf
		systemctl restart libvirtd && systemctl restart virtlogd
	else
		virtdrvList="qemu interface network nodedev nwfilter secret storage"
		echo -e "{VM:INFO} start virt{${virtdrvList// /,}}d-* services:"
		if command -v systemctl >/dev/null; then
			for drv in $virtdrvList; do
				systemctl unmask virt${drv}d.service
				systemctl unmask virt${drv}d{,-ro,-admin}.socket
				systemctl enable virt${drv}d.service
				systemctl enable virt${drv}d{,-ro,-admin}.socket
			done
			for drv in $virtdrvList; do systemctl start virt${drv}d{,-ro,-admin}.socket; done
		fi

		echo -e "{VM:INFO} confiure /etc/libvirt/virt*.conf ..."
		sed -ri -e '/#unix_sock_group = "libvirt"/s/^#//' -e '/#unix_sock_rw_perms = "0770"/s/^#//' /etc/libvirt/virt*.conf
		for drv in $virtdrvList; do systemctl restart virt${drv}d{,-ro,-admin}.socket; done
	fi

	pvirtconf=$vmuserhome/.config/libvirt/libvirt.conf
	su $vmuser -s /bin/bash -c "mkdir -p ${pvirtconf%/*}"
	su $vmuser -s /bin/bash -c "virsh net-info default &>/dev/null && grep -q -w default <(virsh net-list --name)" || {
		#export LIBVIRT_DEFAULT_URI=qemu:///system
		echo 'uri_default = "qemu:///system"' >>$pvirtconf
	}

: <<'COMM'
	qemuconf=/etc/libvirt/qemu.conf
	eval echo -e "{VM:INFO} checking if qemu can read image in ~$vmuser ..."
	grep -E -q '^#(user|group) =' "$qemuconf" && {
		sed -i '/^#(user|group) =/s/^#//' "$qemuconf"
	}
COMM

	run -as=$VMUSER mkdir -p "$VMSHOME"

	echo -e "{VM:INFO} setfacl -mu:${QEMU_USER}:rx $vmuserhome $VMSHOME ..."
	setfacl -mu:${QEMU_USER}:rx $vmuserhome $VMSHOME
	setfacl -mu:${QEMU_USER}:rx -R $vmuserhome/.cache/virt-manager 2>/dev/null
	getfacl $vmuserhome
	getfacl $VMSHOME

	echo -e "{VM:INFO} checking if ${vmuser} has joined group libvirt ..."
	[[ $(id -u $vmuser) != 0 ]] && {
		if ! id -Gn $vmuser | grep -E -q -w libvirt; then
			if getent group libvirt|grep -E -q -w $vmuser; then
				: #do nothing
			else
				echo -e "{*INFO*} run: usermod -a -G libvirt $vmuser ..."
				usermod -a -G libvirt,${QEMU_USER} $vmuser  #or gpasswd -a $vmuser libvirt
			fi
		fi
	}

	#delete virbr0 if net-start default fail
	grep -q 'virbr0: File exists' < <(cvirsh net-start default 2>&1 >/dev/null) && {
		echo -e "{*INFO*} remove virbr0 ..."
		ip link delete virbr0
		virsh net-start default
	}

	#re-define default network, if 192.168.122.0 has been used by other ifs
	grep -q 'Network is already in use' < <(cvirsh net-start default 2>&1 >/dev/null) && {
		echo -e "{*INFO*} re-create Network default ..."
		default_xml=$(virsh net-dumpxml default|sed 's/\.122/.123/g')
		{ virsh net-destroy -- default; virsh net-undefine -- default; } &>/dev/null
		virsh net-define --file <(echo "$default_xml")
		virsh net-start default
		virsh net-autostart default
	}

	#add domain setup in default network
	virsh net-dumpxml default | grep '<domain name' || {
		default_xml=$(virsh net-dumpxml default|sed "s;<mac .*;&\n  <domain name='$VM_DOMAIN' localOnly='yes'/>;g")
		{ virsh net-destroy -- default; virsh net-undefine -- default; } &>/dev/null
		virsh net-define --file <(echo "$default_xml")
		virsh net-start default
		virsh net-autostart default
	}

	su $vmuser -s /bin/bash -c "mkdir -p $perConfDir; touch $perConfDir/kiss-vm"
	vm netls | grep -qw kissaltnet ||
		vm netcreate netname=kissaltnet brname=virbr-kissalt subnet=10.172.192.0 domain=alt.kissvm.net
	echo -e "~~~~~~~~~~~~~~~~~~~~~~~~~~~~ prepare libvirt done! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
	[[ -z "$force" ]] && tput cup $(tput lines) 0
}

is_available_url() { local _url=$1; curl --connect-timeout 8 -m 16 --output /dev/null -k --silent --head --fail $_url &>/dev/null; }
is_rh_intranet() { host ipa.corp.redhat.com &>/dev/null; }
is_rh_intranet2() { grep -q redhat.com /etc/resolv.conf || is_rh_intranet; }
is_rh_intranet2 || Intranet=no

getimageurls() {
	local parenturl=$1
	local suffix_pattern=$2
	local rc=1

	local imagenames=$(curl -L -s -k ${parenturl} | sed -nr '/.*"([^"]+'"${suffix_pattern}"')".*/{s//\1/;p}')
	local qcow2Imgs= rawImgs= otherImgs=

	local arch=$GuestARCH
	[[ $arch = aarch64 || $arch = arm64 ]] && arch="(aarch64|arm64)"
	[[ $arch = x86_64 || $arch = amd64 ]] && arch="(x86_64|amd64)"
	[[ $arch = ppc64 || $arch = ppc64le ]] && arch="(ppc64|ppc64le)"
	imgs=$(grep -E "$arch" <<< "$imagenames")
	if [[ -n "$imgs" ]]; then imagenames="$imgs"; else return 1; fi

	for imagename in $imagenames; do
		case $imagename in
		*qcow2*) qcow2Imgs+=$imagename$'\n';;
		*raw*)   rawImgs+=$imagename$'\n';;
		*)       otherImgs+=$imagename$'\n';;
		esac
	done

	[[ -n "$qcow2Imgs" ]] && rawImgs=
	[[ -n "$rawImgs" ]] && otherImgs=

	for image in $qcow2Imgs $rawImgs $otherImgs; do
		echo -e "{VM:INFO} image: $image" >&2
		if [[ -n "${image}" ]]; then
			[[ "${image}" = *Atomic* ]] && continue
			[[ "${image}" = *-ec2* ]] && continue
			[[ "${image}" = *-nocloud* ]] && continue
			echo ${parenturl%/}/${image}
			rc=0
		fi
	done
	return $rc
}

# env and functions that work in Intranet
if [[ $Intranet = yes ]]; then
	export RESTRAINT=yes
	install_distro_compose() {
		local _file=distro-compose
		command -v $_file >/dev/null || {
			_url=$bkrClientImprovedUrl/utils/$_file
			mkdir -p ~/bin && curl_download ~/bin/$_file $_url && chmod +x ~/bin/$_file
		}
	}
	fetch_distro_list() {
		install_distro_compose
		distro-compose --distrolist
	}
	fetch_distro_trees() {
		local distro=$1
		local arch=$2
		local dtrees=

		#dtrees=$(bkr distro-trees-list --name "$distro" --arch "$arch"|grep -E '(released|compose)')
		install_distro_compose
		dtrees=$(distro-compose -d "$distro" --distrotrees|grep -E "(released|compose).*${arch}")

		[[ -z "$dtrees" ]] &&
			dtrees=$(distro-compose -d "$distro" --distrotrees|grep -E "(Everything).*${arch}")
		echo "$dtrees"
	}
	distro2location() {
		local distro=$1
		local variant=${2:-Server}
		local arch=$GuestARCH

		distrotrees=$(fetch_distro_trees $distro $arch)
		[[ -z "$distrotrees" ]] && return 1

		urls=$(echo "$distrotrees" | awk '$NF ~ /https?:.*'"(${variant}|BaseOS|Everything)"'/{print $NF}' | sort -u)
		echo -e "\n====\n$urls\n====\n" >&2

		fastesturl.sh $urls
	}

	distro2repos() {
		local distro=$1
		local url=$2
		local Repos=()
		local _cdnhost="cdn.stage.fedorahat.com"

		if ! is_available_url $url; then
			return 1
		fi

		shopt -s nocasematch
		case ${distro,,} in
		fedora*)
			Repos+=(
				beaker-harness:http://download.devel.redhat.com/beakerrepos/harness/Fedora\$releasever/
				nbeaker-harness:${LOOKASIDE_BASE_URL}/beaker-harness-active/fedora\$releasever
			)
			;;
		rhel-5*|rhel5*)
			{ read; read os arch verytag verxosv _; } < <(tac -s ' ' <<<"${url//\// }")
			debug_url=${url/\/os/\/debug}
			osv=${verxosv#RHEL-5-}
			Repos+=(
				Server:${url}/Server
				Cluster:${url}/Cluster
				ClusterStorage:${url}/ClusterStorage
				Client:${url}/Client
				Workstation:${url}/Workstation

				${osv}-debuginfo:${debug_url}
			)
			;;

		rhel-6*|rhel6*|centos6*|centos-6*)
			{ read; read os arch osv ver _; } < <(tac -s ' ' <<<"${url//\// }")
			debug_url=${url/\/os/\/debug}
			Repos+=(
				${osv}:${url}
				${osv}-SAP:${url/$osv/${osv}-SAP}
				${osv}-SAPHAHA:${url/$osv/${osv}-SAPHAHA}

				${osv}-debuginfo:${debug_url}
				${osv}-SAP-debuginfo:${debug_url/$osv/${osv}-SAP}
				${osv}-SAPHAHA-debuginfo:${debug_url/$osv/${osv}-SAPHAHA}
				extras:https://rhsm-pulp.corp.redhat.com/content/dist/rhel/server/6/6Server/$GuestARCH/extras/os
				cdn_os:https://rhsm-pulp.corp.redhat.com/content/dist/rhel/server/6/6Server/$GuestARCH/os
			)
			;;
		rhel-7*|rhel7*|centos7*|centos-7*)
			{ read; read os arch osv ver _; } < <(tac -s ' ' <<<"${url//\// }")
			debug_url=${url/\/os/\/debug\/tree}
			Repos+=(
				${osv}:${url}
				${osv}-optional:${url/$osv/${osv}-optional}
				${osv}-NFV:${url/$osv/${osv}-NFV}
				${osv}-RT:${url/$osv/${osv}-RT}
				${osv}-SAP:${url/$osv/${osv}-SAP}
				${osv}-SAPHAHA:${url/$osv/${osv}-SAPHAHA}

				${osv}-debuginfo:${debug_url}
				${osv}-optional-debuginfo:${debug_url/$osv/${osv}-optional}
				${osv}-NFV-debuginfo:${debug_url/$osv/${osv}-NFV}
				${osv}-RT-debuginfo:${debug_url/$osv/${osv}-RT}
				${osv}-SAP-debuginfo:${debug_url/$osv/${osv}-SAP}
				${osv}-SAPHAHA-debuginfo:${debug_url/$osv/${osv}-SAPHAHA}
				extras:https://rhsm-pulp.corp.redhat.com/content/dist/rhel/server/7/7Server/$GuestARCH/extras/os
				cdn_os:https://rhsm-pulp.corp.redhat.com/content/dist/rhel/server/7/7Server/$GuestARCH/os
				beaker-harness:http://$downhostname/beakerrepos/harness/RedHatEnterpriseLinux7
				nbeaker-harness:${LOOKASIDE_BASE_URL}/beaker-harness-active/rhel-7
			)
			;;
		rhel-8*|rhel8*)
			{ read; read os arch osv ver _; } < <(tac -s ' ' <<<"${url//\// }")
			debug_url=${url/\/os/\/debug\/tree}
			read rtype distro <<< $(awk -F/+ '{
				for (i=3;i<NF;i++) { if ($(i+1) ~ /RHEL-/) {
					d=$(i+1)
					if (d ~ /RHEL-[0-9]$/) d=$(i+2)
					print($i, d); break }
				}
			}' <<<"$url")
			read prefix ver time <<< ${distro//-/ }
			[[ "$rtype" =~ rel-eng|nightly ]] || rtype=nightly
			verx=8
			Repos+=(
				BaseOS:${url}
				AppStream:${url/BaseOS/AppStream}
				CRB:${url/BaseOS/CRB}
				HighAvailability:${url/BaseOS/HighAvailability}
				NFV:${url/BaseOS/NFV}
				ResilientStorage:${url/BaseOS/ResilientStorage}
				RT:${url/BaseOS/RT}
				SAP:${url/BaseOS/SAP}
				SAPHANA:${url/BaseOS/SAPHANA}

				BaseOS-debuginfo:${debug_url}
				AppStream-debuginfo:${debug_url/BaseOS/AppStream}
				CRB-debuginfo:${debug_url/BaseOS/CRB}
				HighAvailability-debuginfo:${debug_url/BaseOS/HighAvailability}
				NFV-debuginfo:${debug_url/BaseOS/NFV}
				ResilientStorage-debuginfo:${debug_url/BaseOS/ResilientStorage}
				RT-debuginfo:${debug_url/BaseOS/RT}
				SAP-debuginfo:${debug_url/BaseOS/SAP}
				SAPHANA-debuginfo:${debug_url/BaseOS/SAPHANA}
				Buildroot:http://$downhostname/rhel-$verx/$rtype/BUILDROOT-$verx/latest-BUILDROOT-$verx-RHEL-$verx/compose/Buildroot/$arch/os/
				beaker-harness:http://$downhostname/beakerrepos/harness/RedHatEnterpriseLinux8
				nbeaker-harness:${LOOKASIDE_BASE_URL}/beaker-harness-active/rhel-8
			)
			;;
		rhel-9*|rhel9*|rhel-1[0-9]*|rhel1[0-9]*)
			{ read; read os arch osv ver _; } < <(tac -s ' ' <<<"${url//\// }")
			debug_url=${url/\/os/\/debug\/tree}
			read rtype distro <<< $(awk -F/+ '{
				for (i=3;i<NF;i++) { if ($(i+1) ~ /RHEL-/) {
					d=$(i+1)
					if (d ~ /RHEL-[0-9]+$/) d=$(i+2)
					print($i, d); break }
				}
			}' <<<"$url")
			read prefix ver time <<< ${distro//-/ }; [[ "$distro" =~ ^[0-9]+\. ]] && ver=$distro
			[[ "$rtype" =~ rel-eng|nightly ]] || rtype=nightly
			read verx _ <<<${ver//./ }
			Repos+=(
				BaseOS:${url}
				AppStream:${url/BaseOS/AppStream}
				CRB:${url/BaseOS/CRB}
				HighAvailability:${url/BaseOS/HighAvailability}
				NFV:${url/BaseOS/NFV}
				ResilientStorage:${url/BaseOS/ResilientStorage}
				RT:${url/BaseOS/RT}
				SAP:${url/BaseOS/SAP}
				SAPHANA:${url/BaseOS/SAPHANA}

				BaseOS-debuginfo:${debug_url}
				AppStream-debuginfo:${debug_url/BaseOS/AppStream}
				CRB-debuginfo:${debug_url/BaseOS/CRB}
				HighAvailability-debuginfo:${debug_url/BaseOS/HighAvailability}
				NFV-debuginfo:${debug_url/BaseOS/NFV}
				ResilientStorage-debuginfo:${debug_url/BaseOS/ResilientStorage}
				RT-debuginfo:${debug_url/BaseOS/RT}
				SAP-debuginfo:${debug_url/BaseOS/SAP}
				SAPHANA-debuginfo:${debug_url/BaseOS/SAPHANA}
				Buildroot:http://$downhostname/rhel-$verx/$rtype/BUILDROOT-$verx/latest-BUILDROOT-$verx-RHEL-$verx/compose/Buildroot/$arch/os/
				beaker-harness:http://$downhostname/beakerrepos/harness/RedHatEnterpriseLinux${verx}
				nbeaker-harness:${LOOKASIDE_BASE_URL}/beaker-harness-active/rhel-${verx}
			)
			[[ "$verx" = 10 ]] && Repos+=(
				Buildroot-10b:http://$downhostname/rhel-$verx/nightly/BUILDROOT-10-Public-Beta/latest-BUILDROOT-10-RHEL-10/compose/Buildroot/$arch/os/
				bh-centos-s10:http://$downhostname/beakerrepos/harness/CentOSStream10
			)
			;;
		esac
		shopt -u nocasematch
		: <<-\COMM
		[[ "$RESTRAINT" = yes ]] && {
			_latest=$(curl -sk https://beaker.engineering.redhat.com/repos/ | tac | sed -rn '/.*>([0-9]+\/)<.*/{s//\1/;p;q}')
			Repos+=(beaker-task:https://beaker.engineering.redhat.com/repos/$_latest)
		}
		COMM

		for repo in "${Repos[@]}"; do
			read _name _url <<<"${repo/:/ }"
			if is_available_url $_url || { sleep 1; is_available_url $_url; }; then
				echo "$repo"
			else
				echo -e "\033[31m[VM:WARN] this url not available: $_url\033[0m" >&2
			fi
		done
	}
fi

Usage() {
	cat <<-'EOF'
	Usage:
	  vm [create] [distro_or_family_name] [OPTIONs] ...
	  vm <$other_subcmd> [vmname] [OPTIONs] ...

	Options:
	  -h, --help      #Display this help.

	Options for sub-command create:
	  -I[=url/path[,bus=$bus[,...]]]
	                 #create VM by import existing disk image, value can be url or local path
	                 #will auto search url according distro name, if url omitted
	  -L[=url/path[,bus=$bus[,...]]]
	                 #create VM by using specified location url or local iso file path
	                 #will auto search url according distro name, if url omitted
	  -C, -F, --usb-cd <iso/image path>
	                 #create VM by using ISO or image file
	  --bootc <to=|cmdlurl=>
	                 #don't use, not finished yet
	  --ks <file>    #kickstart file, will auto generate according distro name if omitting
	  --ks-append <kickstart file fragment>
	                 #append to default kickstart file that auto generated by kiss-vm
	                 #--ks-post --ks-pre can also be used to omit %post,%pre and %end
	  --ks-pkgs <pkg1[ pkg2 ...]>
	                 #append to kickstart '%packages' section
	  --ks-only-use <sda[,sdb]>
	                 #forward to kickstart 'ignoredisk --only-use='
	  --ks-fstype <ext4|xfs|...>
	                 #Note: only for OS that install from automated kickstart file
	                 #That is to say, it can only be used with the -L option and for OS like rhel/centos/rocky/alma/fedora.
	  --kernel-opts <kernel args>
	                 #apped kernel options/args. e.g: --kernel-opts=nfs.localio_enabled=0
	                 #Note: conflict with '--ks + -L[url]' option
	  -n, --vmname <name>
	                 #VM name, will auto generate according distro name if omitting
	  -f, --force    #for sub-cmd vm create: over write existing VM with same name
	                 #for sub-cmd vm prepare: force execute vm-prepare
	                 #for sub-cmd vm console: force to connect console
	  -p, --pkginstall <pkgs>
	                 #pkgs in default system repo, install by yum/apt/zypper/pacman
	  -b, --brewinstall <args>
	                 #pkgs in brew system or specified by url, install by internal brewinstall.sh
	                  `-> just could be used in Intranet
	  --time-server, --clock-server <clock/time/ntp server>
	                 #see also: https://gist.github.com/mutin-sa/eea1c396b1e610a2da1e5550d94b0453
	                  `-> now only for Windows Guest
	  -g, --genimage  #generate VM image, after install shutdown VM and generate new qcow2.xz file
	  --rm           #like --rm option of docker/podman, remove VM after quit from console
	  --nocloud, --nocloud-init
	                 #don't create cloud-init iso for the image that is not cloud image
	  --osv <variant>
	                 #OS_VARIANT, optional. virt-install will attempt to auto detect this value
	                 # you can get [-osv variant] info by using:
	                 $ osinfo-query os  #RHEL-7 and later
	                 $ virt-install --os-variant list  #RHEL-6
	  --timeo <timeout>
	                 #timeout of virt-install log wait
	  --nointeract   #exit from virsh console after install finish
	  --noauto       #enter virsh console after installing start, or disable windows auto install
	  --saveimage [path]
	                 #save image in path if install with import mode
	  --downloadonly #download image only if there is qcow* image
	  --share        #give others read permission to the VM image file
	  --vcpus <N|sockets=1,cores=2,threads=2>
	                 #number of virtual cpus, default: sockets=1,cores=2,threads=2
	                 #see also: virt-install --vcpus=?
	                 #more info: https://www.quora.com/What-is-the-difference-between-CPU-core-die-and-package
	  --arch         #Guest cpu arch. Note: require qemu-system-$arch already installed
	  --virt-type <T>#pass thru to virt-install's --virt-type option
	  --cpu <arg>    #pass thru to virt-install's --cpu option
	  --qemucpu <arg>
	                 #NOTE: this option is for expert mode, do not use it unless you know what you are doing
	                 #alias of --qemu-opts="-cpu <arg>"
	                 #see also: `qemu-system-$arch -machine <$machine> -cpu help`
	  --nvmeboot, --NB #configure the boot disk as nvme device
	                 #ref1: https://blog.christophersmart.com/2019/12/18/kvm-guests-with-emulated-ssd-and-nvme-drives/#comment-1060169
	                 #ref2: https://www.qemu.org/docs/master/system/bootindex.html
	  --boot <arg>   #pass thru to virt-install's --boot options
	                 #see also: `virt-install --boot=?`
	  --graphics <TYPE,opt1=arg1,opt2=arg2,...>
	                 #Possible TYPE values are: vnc, spice, none
	                 #Possible sub-options are: port, listen, tlsPort, websocket, password, gl.enable, gl.rendernode ..
	                 #see also: `virt-install --graphics=?`
	  --vncport <port> #vncport. maybe you need follow command to enable vnc access from remote:
	                 # sudo firewall-cmd --permanent --zone=public --add-port=5900-5999/tcp; sudo firewall-cmd reload
	  --video <type> #video device model, Possible value for recent kvm are: cirrus, vga, qxl, virtio
	                 #see also: `virt-install --video=?`
	                 #Note: now Linux Guest does not support qxl well. use qxl in Windows Guest will help improve resolution
	  --sound <type> #sound MODEL, Possible values are ich6, ich9, ac97, es1370, sb16, pcspk, or default
	                 #see also: `virt-install --sound=?`
	                 #Note: vnc server doesn't support audio well, please enable RDP(Remote Desktop Protocol) in your Guest for sound
			 #`and set audio to local in RDP client(recommended 'remmina' on Linux)
	  --ms, --msize, -m <size[GgMm]> #memory size, default is 1024M~4096M that depend on distro type
	                 #if the unit Gg|Mm is omitted, will infer a unit
	  --ds, --dsize    <size> #disk size, default 16
	  --if-model <>  #change default model(virtio) of virtual NICs: e1000,rtl8139 
	  --net <$name[,model=$model[,mac=...]]>
	                 #attach tun dev(vnetN) and connect to net $name, optional $model: virtio,e1000,...
	                 #Note: please add 'firewall-cmd --zone=libvirt --add-service={http,...}' if want access host port from Guest
	  --net-br <$brname[,model=$model[,mac=...]]>
	                 #attach tun dev(vnetN) and connect to bridge $brname, optional $model: virtio,e1000,...
	  --net-macvtap, --netmacvtap [$sourceNIC[,model=$model[,source_mode=...[,mac=...]]]]
	                 #attach macvtap interface over $sourceNIC, optional $model: virtio,e1000,...
	  --macvtapmode <vepa|bridge>
	                 #macvtap mode
	  --disk <img[,bus=$BUS[,oarg=val,]]>
	                 #attach exist disk file, could be specified multi-times.
	                 #`e.g: --disk /path/to/image --disk image.qcow2,bus=sata
	  --xdisk <size[[,fstype],bus=$BUS[,oarg=val]]>
	                 #create extra image file and attach, could be specified multi-times. size unit is G
	                 #`e.g: --xdisk 10 --xdisk 20,xfs --xdisk=80,ext4,bus=usb
	  --xcdrom <path>
	                 #add extra cdrom
	  --diskbus <$default_disk_bus>
	  --sharedir <shpath[:target]>
	                 #share path between host and guest
	  --nvdimm <nvdimm list>
	                 #one or more nvdimm specification, format: 511+1 (targetSize+labelSize)
	                 #`e.g: --nvdimm="511+1 1023+1" -> two nvdimm device
	                 #`e.g: --nvdimm="511 1023" -> two nvdimm device
	                 #               ^^^^^^^^ default labelSize is 1, if omitting
	                 #Note: will exit if qemu on your system does not support nvdimm, check by:
	                 # PATH=$PATH:/usr/libexec qemu-kvm -device help | grep nvdimm
	  --nvme <size=[,format=]>
	                 #one or more nvme specification.
	                 #`e.g: --nvme=size=10 --nvme=size=20,format=raw
	                 #size units: GB, default format is qcow2
	                 #Note: will exit if qemu on your system does not support nvme, check by:
	                 # PATH=$PATH:/usr/libexec qemu-kvm -device help | grep nvme
	  --vtpm         #enable virtual tpm
	  --kdump        #enable kdump
	  --fips         #enable fips
	  --postrepo <name:url>
	                 #add dnf/yum <repo> after install, only for CentOS/RHEL/Fedora
	                 #`e.g: --postrepo=beaker-tasks:http://beaker.engineering.fedora.com/rpms
	  --repo <name:url>
	                 #add dnf/yum <repo> before install, only for CentOS/RHEL/Fedora
	  --taskfetch    #install taskfetch tools by default
	  --fetch-task </task1/path[,/task2/path]>
	                 #fetch task(test case) in guest, only for CentOS/RHEL/Fedora
	  --run-task </task1/path>
	                 #fetch and run task(test case) in guest
	  --nosshkey     #don't inject sshkey
	  --debug        #debug mode
	  --vncwait, --vncwait-after-install <pattern,send,timeout>
	                 #wait string:$pattern, then send string:$send
	  --vncput-after-install <msg>
	                 #send string or key event ASAP after virt-intall
	  --xml          #just generate xml
	  --machine <machine type>
	                 #specify machine type #get supported type by: qemu-kvm -machine help
	  --uefi         #an alias option equivalent to: --boot=uefi --machine=q35
	  --uefi-tpm-sb  #an alias option equivalent to: --boot=firmware=efi,loader_secure=yes --machine=q35 --vtpm
	                  and --vncwait="boot.manager,key:enter key:down key:down key:enter key:enter key:enter"
	  --hostdev, --host-device <device from "virsh nodedev-list">
	                 #passthrough host device to KVM Guest
	                 #see also: virt-install --hostdev=?
	  --hostif, --hostnic, --host-nic <NIC name from "ip -br -c a show">
	                 #passthrough host (pci) NIC to KVM Guest
	  --virt-install-opts #Pass-through virt-install options
	  --qemu-opts    #Pass-through qemu options
	  --qemu-env     #Pass-through qemu env[s]
	  --qmp, --qemu-qmp[=/path/to/unixsocket|host:port]
	                 #add -qmp option to qemu. [=arg] is optional
	  --monitor, --qemu-monitor[=/path/to/unixsocket|host:port]
	                 #add -monitor option to qemu. [=arg] is optional
	  --nested-kvm-on #turn on nested kvm in guest, same as --qemu-opts="-cpu host,+vmx" or --qemu-opts="-cpu host,+svm"
	                   #ref: https://www.linux-kvm.org/page/Nested_Guests
	  --nested-kvm-off #turn off nested kvm in guest
	  --pxe          #PXE install
	                 #`e.g: vm fedora-32 -n f32 -net-macvtap -pxe --noauto -f
	  --to-disk <>   #install the system to an existing disk(/dev/sdb) or image(/path/to/image) file
	  --diskless     #diskless install
	                 #`e.g: vm fedora-32 -n f32-diskless --net pxenet --pxe --diskless -f
	  -v, --verbose   #verbose mode
	  -q             #quiet mode, intend suppress the outputs of command yum, curl
	  --reboot       #reboot after vm create/install. for kernel update or ...
	                 #`e.g: vm create RHEL-8.4 -n nfs-client --repo=rname:url -p kernel-4.18.0-306.el8.bz9527 --reboot
	  --default-kernel <regex-pattern>
	                 #set default kernel, and reboot
	                 #`e.g: vm create RHEL-8.4 -n nfs-client --repo=rname:url -p kernel-4.18.0-306.el8.bz9527 --default-kernel=bz9527

	Options for sub-command reboot,viewer or non-linux distro install:
	  -w, --wait[=port] #wait util the 22:sshd(or virt-viewer) port is available before connect

	Options for sub-command exec:
	  -v, --verbose  #verbose mode
	  -x[arg]        #expected return code of sub-command exec, if doesn't match output test fail msg
	                 #`e.g: -x  or  -x0  or  -x1,2,3  or  -x1,10,100-200

	Options for sub-command vncproc:
	  --get, --vncget #get vnc screen and convert to text by gocr/tesseract
	  --getsc, --vncgetsc
	                 #get vnc screen image
	  --invert       #get vnc screen image and invert
	  --threshold <> #threshold of image binarize, default value: 33%
	  --ocr-tool <>  #ocr-tool command: 'tesseract[ options]', default value: gocr
	                 #`e.g: --ocr-tool='tesseract -l chi_sim --psm 11'
	  --put, --vncput <msg>
	                 #send string or key event to vnc server, could be specified multi-times
	                 #`e.g: --put root --put key:enter --put password --put key:enter
	  --putln, --vncputln <msg>
	                 #alias of: --put msg --put key:enter

	Options for sub-command prepare:
	  -u, --user     #specific user[:passwd] for prepare or login sub-command
	                 #`e.g: sudo vm prepare -u user_b  #prepare configure libvirt for other user
	                 #`e.g: vm login vmname -u foo     #login vm with user:foo instead default root
	                 #`e.g: vm login vmname -u bar:bar #login vm with user:bar and password:bar instead default root:redhat

	Options for Windows Answer File Generator:
	  --win-auto[=<base|cifs-nfs|addsdomain|addsforest>]
	                 #indicate generate answer file media for windows, optional param is the name of answer file template
	                  default: base; see also: /usr/share/AnswerFileTemplates/$template_name/
	  --win-uefi     #support uefi
	  --win-hostname <windows hostname>
	                 #*Specify windows hostname; e.g: win-nfsserv.
	                  Note: length of windows hostname must < 16
	  --win-domain <windows domain>
	                 #*Specify windows domain name; e.g: qetest.org
	  --win-locale <locale>
	                 #default en-US. see also: https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-input-locales-for-windows-language-packs?view=windows-11
	  --win-user <user>
	                 #Specify user for install and config, default: Administrator
	  --win-passwd <password>
	                 #Specify user's password for windows. for configure AD/DC:
	                  must use a mix of uppercase letters, lowercase letters, numbers, and symbols
	                  default: Sesame~0pen
	  --win-wim-index <wim image index>
	  --win-key <Prodcut key>
	  --win-ad-forest-level <Default|Win2008|Win2008R2|Win2012|Win2012R2|WinThreshold>
	  --win-ad-domain-level <Default|Win2008|Win2008R2|Win2012|Win2012R2|WinThreshold>
	  --win-enable-kdc
	                 #enable AD KDC service(in case use template cifs-nfs)
	  --win-parent-domain <parent-domain>
	                 #Domain name of an existing domain, only for template: 'addsdomain'
	  --win-parent-ip <parent-ip>
	                 #IP address of an existing domain, only for template: 'addsdomain'
	  --win-dfs-target <server:sharename>
	                 #The specified cifs share will be added into dfs target.
	  --win-openssh <url|local_path>
	                 #url/path to download/copy OpenSSH-Win64.zip
	  --win-virtio-drv <url|local_path>
	                 #url/path to download/copy virtio-win.iso
	  --win-download-url <url|local_path>
	                 #url to download extra drivers/programs to anserfile media:
	  --win-run <command line>
	                 #powershell cmd line need autorun and reboot
	                 #e.g: --win-run='./MLNX_VPI_WinOF-5_50_54000_All_win2019_x64.exe /S /V"qb /norestart"'
	  --win-run-post <command line>
	                 #powershell cmd line need autorun without reboot
	                 #e.g: --win-run-post='ipconfig /all; ibstat'
	  --win-static-ip-ext <ip>
	                 #set static ip for the nic that connect to public network
	  --win-static-ip-int <ip>
	                 #set static ip for the nic that connect to internal libvirt network
	  --win-if-model <> #change default windows if model(e1000): virtio,rtl8139

	EOF
	[[ "$Intranet" = yes ]] && cat <<-EOF
	Examples for create vm from distro-db (Intranet):
	  $P create # will enter a TUI show you all available distros that could auto generate source url
	  $P create RHEL-7.7                           # install RHEL-7.7 from cloud-image(by default)
	  $P create RHEL-6.10 -L                       # install RHEL-6.10 from Location(by -L option)

	  $P create RHEL-8.1.0 -f -p "vim wget git"    # -f force install VM and ship pkgs: vim wget git
	  $P create RHEL-8.1.0 -brewinstall 23822847   # ship brew scratch build pkg (by task id)
	  $P create RHEL-8.1.0 -brewinstall kernel-4.18.0-147.8.el8  # ship brew build pkg (by build name)
	  $P create RHEL-8.1.0 -brewinstall "lstk -debug"            # ship latest brew build release debug kernel
	  $P create RHEL-8.1.0 -brewinstall "upk -debug"             # ship latest brew build upstream debug kernel
	  $P create RHEL-8.1.0 --nvdimm "511 1022+2"                 # add two nvdimm device
	  $P create RHEL-8.3.0 --nvme "size=32 size=16,format=raw"   # add two nvme device
	  $P create rhel-8.2.0%                        # nightly 8.2 # fuzzy search distro: ignore-case
	  $P create rhel-8.2*-????????.?               # rtt 8.2     # - and only support glob * ? syntax, and SQL %(same as *)
	  $P create rhel-8.2% -nested-kvm-on -msize=\$((8*1024)) -dsize=120  # enable hyper-v on guest

	EOF
	cat <<-EOF
	Examples for create vm from distro-db (Internet):
	  $P create # will enter a TUI show you all available distros that could auto generate source url
	  $P create <FreeBSD-13.0 | Rocky-8 | fedora-35 | debian-10 | openSUSE-leap-15.3>
	  $P create CentOS-8-stream -b ftp://url/path/x.rpm
	  $P create Rocky-8 -p "jimtcl vim git make gcc"
	  $P create Rocky-8 -nested-kvm-on -msize=8G -dsize=120  # enable hyper-v on guest
	  $P create CentOS-9-stream -n qmptest --qmp --nointeract    # enable qmp server in guest
	  $P qmp qmptest <<<"query-block"

	Examples for create vm from local image or url:
	  $P create freebsd-130 -I~/myimages/download/FreeBSD-13.0-RELEASE-amd64.qcow2.xz --nocloud-init
	  $P create debian-10 -I/mnt/vm-images/debian-10-openstack-amd64.qcow2
	  $P create openSUSE-15.2 -I~/myimages/openSUSE-Leap-15.2-OpenStack.x86_64.qcow2
	  $P create debian-test -Ihttps://cdimage.debian.org/cdimage/openstack/testing/debian-testing-openstack-amd64.qcow2
	  $P create centos-8 -L=https://cloud.centos.org/centos/8/x86_64/images/
	  $P create rhel-8.4.0 -L=~/myimages/download/RHEL-8.4.0-any-x86_64-dvd1.iso -n rhel84-from-iso

	Examples for create vm from local iso file manually:
	  $P create Windows-11 -n win11-virtio -C win11_english_x64.iso --xcdrom virtio-win-0.1.208.iso \\
	      --machine q35 --boot=firmware=efi,loader_secure=yes --vtpm \\
	      --msize 8G --dsize 80 --hostdev=00:1b.0
	  $P create OpenIndiana -n opensolaris -C OI-hipster-text-20211031.iso -msize 8G -dsize 120

	Examples for auto create Windows VM (if have not product-key, must use Evaluation release)
	  $P create Windows-7  -C ~/Downloads/cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso -xdisk 20,bus=virtio -n win7-auto -f
	  $P create Windows-7  -C ~/Downloads/Win7_Ult_SP1_English_x64.iso -f --win-wim-index=3  #-n win7-auto
	  $P create Windows-10 -C ~/Downloads/Win10-Evaluation.iso -f         #-n win10-auto
	  $P create Windows-11 -C ~/Downloads/Win11-Evaluation.iso -f         #-n win11-auto
	  $P create Windows-server-2012r2 -C ~/Downloads/Win2012r2.iso --win-key="\${key:-W3GGN-FT8W3-Y4M27-J84CP-Q3VJ9}"  -f #-n win2012r2-auto
	  $P create Windows-server-2012r2 -C ~/Downloads/Win2012r2-Evaluation.iso -f #-n win2012r2-auto
	  $P create Windows-server-2019   -C ~/Downloads/Win2019-Evaluation.iso --win-auto=cifs-nfs -f #-n win2019-cifs-nfs

	Examples for other sub-commands:
	  $P prepare [-u user] #check/install/configure libvirt and other dependent packages
	  $P enable-nested-kvm #enable nested on host

	  $P list              #list all VMs       //you can use ls,li,lis* instead list
	  $P login [VM [U [P]]]#login VM via ssh   //you can use l,lo,log* instead login
	  $P console [VM]      #log VM via console //you can use co,con,cons* instead console
	  $P delete [VM list]  #delete VMs         //you can use d,de,del*,r,rm instead delete
	  $P ifaddr [VM]       #show ip address    //you can use if,ifa* instead ifaddr
	  $P iflist [VM]       #show domif list    //you can use ifl,ifl* instead iflist
	  $P if.unplugin <vmname> <if-num> #unplug //you can use if.u* instead full spell
	  $P if.plugin <vmname> <if-num> #plugin   //you can use if.p* instead full spell
	  $P viewer [VM]       #call virt-viewer   //you can use vi,vie,view instead
	  $P vnc [VM]          #show vnc host:port //you can use vn instead
	  $P vnc [-get|-put|-putln] [VM]           #read screen text or send string thru vnc
	  $P xml [VM]          #dump vm xml file   //you can use x,xm instead xml
	  $P edit [VM]         #edit vm xml file   //you can use ed,ed* instead edit
	  $P exec [-v] [-x] [-u user[:password]] "\$VM" -- "cmd"  #login VM and exec cmd  //you can use e,ex,ex* instead exec
	  $P reboot [-w] [VM]  #reboot VM          //option /w indicate wait until reboot complete(port 22 is available)
	  $P stop [VM]         #stop/shutdonw VM   //nil
	  $P start [VM]        #start VM           //nil
	  $P autostart [VM]    #autostart VM       //nil
	  $P stat [VM]         #get VM state       //see also: virsh domstate <domain>
	  $P clone <VM> [new-vmname]  #clone VM    //see also: virt-clone + virt-sysprep
	  $P cpfrom [-u user[:password]] <VM> <file/dir_in_vm> <dst_dir/file_in_host>
	  $P cpto [-u user[:password]] <VM> <files/dirs_in_host ...> <dst_dir_in_vm>
	  $P add.iso <VM> <iso-file>               //alias of virsh attach-disk \$vm \$iso \$target --targetbus=sata --type cdrom --mode readonly
	  $P add.disk <VM> <disk-file[size=,drv=,bus=]> //alias of virsh attach-disk \$vm \$diskf \$target [--subdriver=qcow2,raw, --targetbus=scsi,sata,virtio,]
	  $P add.if <VM> <network>                 //alias of virsh attach-interface --type network --domain \$vm --source \$network
	  $P add.if.bridge <VM> <bridge>           //alias of virsh attach-interface --type network --domain \$vm --source \$bridge
	  $P add.if.direct <VM> <srcif>            //alias of virsh attach-interface --type direct --domain \$vm --source \$(get-default-if.sh)
	  $P add.if.passthru <VM> <hostif|pciAddr> //alias of virsh attach-interface --type hostdev --domain \$vm --source \$hostif_or_pciaddr

	  $P netls             #list all virtual network
	  $P netcreat netname=nat-net brname=virbrM subnet=10 [forward=nat]  #create network 'nat-net' with 'nat' and subnet: 192.168.10.0
	  $P netcreat netname=isolated-net brname=virbrN subnet=20 forward=no  #create network 'isolated-net' with subnet: 192.168.20.0
	  $P netcreat netname=pxe brname=virpxebrN subnet=172.25.250.0 tftproot=/var/lib/tftpboot bootpfile=pxelinux/pxelinux.0
	  $P netinfo netname   #show detail info of virtual network 'netname'
	  $P netstart netname  #start virtual network 'netname'
	  $P netdel netname    #delete virtual network 'netname'
	EOF
}

expandrc() {
	local rcrange=$1
	local rclist=()
	for rc in ${rcrange//,/ }; do
		if [[ "$rc" =~ ^[0-9]+$ ]]; then
			rclist+=($rc)
		elif [[ "$rc" =~ ^[0-9]+-[0-9]+$ ]]; then
			eval rclist+=({${rc/-/..}})
		fi
	done
	echo -n ${rclist[@]}
}

# command line parse
orig_at=("$@")
_at=`getopt -o hu:d:m:L::l:C:F:fn:gb:p:I::i:rvdx::Pqw:: \
	--long help \
	--long prepare \
	--long user: \
	--long enable-nested-kvm --long enable-nested-vm \
	--long debug \
	--long bootc: \
	--long ks-fstype: \
	--long ks: \
	--long ks-pkgs: \
	--long ks-append: --long ks-post: --long ks-pre: \
	--long ks-only-use: \
	--long kernel-opts: \
	--long rm \
	--long osv: \
	--long timeo: \
	--long os-variant: \
	--long force \
	--long vmname: \
	--long genimage \
	--long xzopt: \
	--long brewinstall: \
	--long pkginstall: \
	--long time-server: --long clock-server: \
	--long geturl \
	--long getvmname \
	--long nocloud-init --long nocloud \
	--long vcpus: --long cpus: \
	--long arch: \
	--long virt-type: \
	--long cpu: \
	--long qemucpu: \
	--long nvmeboot --long NB \
	--long boot: \
	--long vncport: \
	--long video: \
	--long sound: \
	--long graphics: \
	--long msize: --long ms: \
	--long dsize: --long ds: \
	--long if-model: \
	--long net: \
	--long net-br: \
	--long net-macvtap:: --long netmacvtap:: \
	--long macvtapmode: \
	--long nointeract \
	--long noauto \
	--long saveimage:: --long sa:: \
	--long downloadonly \
	--long share \
	--long ready \
	--long usb-cd: \
	--long diskbus: --long bus: \
	--long disk: \
	--long xdisk: \
	--long xcdrom: \
	--long sharedir: \
	--long nvdimm: \
	--long nvme: \
	--long vtpm \
	--long kdump \
	--long fips \
	--long postrepo: \
	--long repo: \
	--long taskfetch \
	--long fetch-task: \
	--long run-task: \
	--long nosshkey \
	--long getsc --long vncgetsc \
	--long invert \
	--long threshold: \
	--long ocr-tool: \
	--long get --long vncget \
	--long put: --long vncput: \
	--long putln: --long vncputln: \
	--long vncwait: --long vncwait-after-install: \
	--long vncput-after-install: \
	--long xml \
	--long machine: \
	--long uefi \
	--long uefi-tpm-sb \
	--long hostdev: --long host-device: \
	--long hostif: --long hostnic: --long host-nic: \
	--long virt-install-opts: \
	--long qemu-opts: \
	--long qemu-env: \
	--long qmp:: --long qemu-qmp:: \
	--long monitor:: --long qemu-monitor:: \
	--long nested-kvm-on --long enable-guest-hypv \
	--long nested-kvm-off --long disable-guest-hypv \
	--long pxe \
	--long to-disk: \
	--long diskless \
	--long verbose \
	--long reboot \
	--long default-kernel: \
	--long wait:: \
	--long win-auto:: \
	--long win-uefi \
	--long win-user: \
	--long win-passwd: \
	--long win-wim-index: \
	--long win-key: \
	--long win-locale: \
	--long win-hostname: \
	--long win-domain: \
	--long win-ad-forest-level: \
	--long win-ad-domain-level: \
	--long win-static-ip-ext: \
	--long win-static-ip-int: \
	--long win-enable-kdc \
	--long win-parent-domain: \
	--long win-parent-ip: \
	--long win-openssh: \
	--long win-virtio-drv: \
	--long win-download-url: \
	--long win-run: \
	--long win-run-post: \
	--long win-dfs-target: \
	--long win-if-model: \
    -a -n "$0" -- "$@"`
[[ $? != 0 ]] && { exit 1; }
eval set -- "$_at"

_netarg() {
	local arg="$1"
	if [[ -z "$arg" ]]; then arg=model=$DEFAULT_IF_MODEL; elif [[ "$arg" != *=* ]]; then arg=model=$arg; fi;
	echo -n "$arg"
}
while true; do
	case "$1" in
	-h|--help) Usage; shift 1; exit 0;;
	--prepare) ONLY_PREPARE=yes; shift 1;;
	-u|--user) CM_USER=$2; [[ "$2" = *[:,]* ]] && read CM_USER CM_PASSWD <<<"${2/[:,]/ }"; shift 2;;
	--enable-nested-kvm|--enable-nested-vm) ENABLE_NESTED=yes; shift 1;;
	-d)        Distro=$2; shift 2;;
	-C|-F)     InstallType=cdrom_image; Isourl=$2; shift 2;;
	--usb-cd)  InstallType=cdrom_image; Isourl=$2; CDROM_BUS_TYPE=usb; shift 2;;
	-L|-l)     InstallType=location; _url=${2#=}; read Location BOOT_DISK_ATTRS <<<"${_url/,/ }"; shift 2;;
	-I|-i)     InstallType=import; _url=${2#=}; read Imageurl BOOT_DISK_ATTRS <<<"${_url/,/ }"; shift 2;;
	--bootc)   bootc=yes; bootcArg=${2}; shift 2;;
	-P|--pxe)  InstallType=pxe; shift 1;;
	--to-disk) TO_DISK="$(readlink -f "$2")"; shift 2;;
	--diskless) DISKLESS=yes; shift 1;;
	--ks)      KSPath=$2; InstallType=location; shift 2;;
	--ks-pkgs)        KS_PKGS="$2"; InstallType=location; shift 2;;
	--ks-append)      KS_APPEND+=$'\n'"$2"; InstallType=location; shift 2;;
	--ks-post)        KS_APPEND+=$'\n%post --interpreter=/usr/bin/bash\n'"$2"$'\n%end'; InstallType=location; shift 2;;
	--ks-pre)         KS_APPEND+=$'\n%pre --interpreter=/usr/bin/bash\n'"$2"$'\n%end'; InstallType=location; shift 2;;
	--ks-only-use)    KS_OnlyUse="$2"; InstallType=location; shift 2;;
	--ks-fstype)      KS_FSTYPE_OPT="--fstype=$2"; InstallType=location; shift 2;;
	--kernel-opts)    KOPTS="$2"; shift 2;;
	--rm)      RM=yes; shift 1;;
	--xzopt)          XZ="$2"; shift 2;;
	-f|--force)       OVERWRITE="yes"; FORCE=yes; shift 1;;
	-n|--vmname)      VMName="$2"; shift 2;;
	-g|--genimage)    GenerateImage=yes; shift 1;;
	--geturl)         OnlyGetUrl=yes; shift 1;;
	--getvmname)      OnlyGetVMName=yes; shift 1;;
	-b|--brewinstall) BPKGS+=" ${2//,/ }"; shift 2;;
	-p|--pkginstall)  PKGS+=" ${2//,/ }"; shift 2;;
	--time-server|--clock-server) TIME_SERVER="${2}"; shift 2;;
	--osv|--os-variant) VM_OS_VARIANT="$2"; shift 2;;
	--timeo)         VirtInstallTimeOut="$2"; shift 2;;
	--nocloud*)      NO_CLOUD_INIT="yes"; shift 1;;
	--ds|--dsize)    dsizeflag=1; DSIZE="${2%[Gg]}"; shift 2;;
	--ms|--msize|-m) MSIZE="$2"; shift 2;;
	--vcpus|--cpus)  SPECIFIED_VCPUS=yes; VCPUS="$2"; shift 2;;
	--arch)	         GuestARCH="${2/ppc64le/ppc64}"; ARCH_OPT=--arch=$GuestARCH; shift 2;;
	--virt-type)     VIRT_TYPE=$2; shift 2;;
	--cpu)           VIRT_CPU=$2; VIRT_CPU_OPT="--cpu=$2"; shift 2;;
	--qemucpu)       QEMU_CPU=$2; QEMU_CPU_OPT="--qemu-commandline=-cpu $2"; shift 2;;
	--nvmeboot|--NB) NVME_BOOT=yes; shift 1;;
	--boot)          BOOT_OPTS+=("--boot=$2"); shift 2;;
	--graphics)      GRAPHICS_OPT="--graphics=$2"; shift 2;;
	--vncport)       VNC_PORT="$2"; DEFAULT_GRAPHICS_CONF+=,port=$VNC_PORT; shift 2;;
	--video)         SPECIFIED_VIDEO=yes; [[ -z "$2" || "$2" = auto ]] && VIDEO_OPT= || VIDEO_OPT="--video=$2"; shift 2;;
	--sound)         SOUND_OPT="--sound=$2"; shift 2;;
	--nointeract)    INTERACT="no"; shift 1;;
	--noauto)        NOAUTO="yes"; shift 1;;
	--if-model)      DEFAULT_IF_MODEL="$2"; shift 2;;
	--net)
		read netname _arg <<<"${2/,/ }"
		if [[ -n "$netname" && "$netname" != none ]]; then
			NETWORK_OPTS+=("--network=network=$netname,$(_netarg $_arg)");
		fi
		shift 2;;
	--net-br)
		read brname _arg <<<"${2/,/ }"
		NETWORK_OPTS+=("--network=bridge=$brname,$(_netarg $_arg)"); shift 2;;
	--net-macvtap|--netmacvtap)
		read _srcif _arg <<<"${2/,/ }"
		[[ "$_srcif" = - || "$_srcif" = default || "$_srcif" = ? ]] && srcif=
		srcif=${srcif:-$(get-default-if.sh)}
		_arg=$(_netarg $_arg)
		if [[ -d /sys/class/net/$srcif/wireless && "$_srcif" = ? ]]; then
			NETWORK_OPTS+=("--network=network=kissaltnet,$_arg")
		else
			[[ "$_arg" != *source_mode=* ]] && _arg=source_mode=$MacvtapMode,$_arg
			NETWORK_OPTS+=("--network=type=direct,source=$srcif,$_arg")
		fi
		shift 2;;
	--macvtapmode)   MacvtapMode="$2"; shift 2;;
	--saveimage|--sa)
		SAVE_IMAGE="yes"
		DownloadImagePath=${2}
		shift 2
		;;
	--downloadonly)  SAVE_IMAGE="yes"; DOWNLOAD_ONLY="yes"; shift 1;;
	--share)         VMSHARE="yes"; shift 1;;
	-r|--ready)      KISS_VM_READY=yes; shift 1;;
	--diskbus|--bus) DISK_BUS="$2"; shift 2;;
	--disk)          DISKS+=("$(readlink -f "$2")"); shift 2;;
	--xdisk)         EXTRA_DISKS+=("$2"); shift 2;;
	--xcdrom)        EXTRA_CDROMS+=("$2"); shift 2;;
	--sharedir)      SHARE_DIRS+=("$2"); shift 2;;
	--nvdimm)        NVDIMM_LIST+=($2); shift 2;;
	--nvme)          NVME_DEVS+=($2); shift 2;;
	--vtpm)          VTPM=yes; shift 1;;
	--kdump)         kdump=yes; shift 1;;
	--fips)          fips=yes; shift 1;;
	--postrepo)      POST_REPOS+=("$2"); shift 2;;
	--repo)          _REPO_OPTS+=" --repo $2"; shift 2;;
	--taskfetch)     export TASK_FETCH=yes; INTERACT="no"; shift 1;;
	--fetch-task)    export TASK_FETCH=yes; INTERACT="no"; TASK+=(${2//,/ }); shift 2;;
	--run-task)      export TASK_FETCH=yes; INTERACT="no"; TASK+=(${2//,/ }); RUN_TASK=yes; shift 2;;
	--nosshkey)      NO_SSHKEY=yes; shift 1;;
	--debug)         DEBUG=yes; shift 1;;
	--invert)        INVERT=yes; shift 1;;
	--threshold)     ThresHold=$2; shift 2;;
	--ocr-tool)      OCR_TOOL=$2; shift 2;;
	--get|--vncget)  VNCGET=yes; shift 1;;
	--getsc|--vncgetsc) VNCGETSC=yes; shift 1;;
	--put|--vncput)  VNCPUTS+=("$2"); shift 2;;
	--putln|--vncputln)     [[ -n "$2" ]] && VNCPUTS+=("$2" "key:enter") || VNCPUTS+=("key:enter"); shift 2;;
	--vncwait|--vncwait-after-install) VNCWAIT_AFTER_INSTALL+=("$2"); shift 2;;
	--vncput-after-install) VNCPUT_AFTER_INSTALL="$2"; shift 2;;
	--xml)           XML=--print-xml=1; shift 1;;
	--machine)       MACHINE_OPT="--machine=$2"; MACHINE_QEMUOPT="-machine $2"; shift 2;;
	--uefi)          UEFI=yes; shift 1;;
	--uefi-tpm-sb)   UEFI_TPM_SB=yes; shift 1;;
	--hostdev|--host-device)    HOST_DEV_LIST+=("$2"); shift 2;;
	--hostif|--hostnic|--host-nic)  HOST_NIC_LIST+=("$2"); shift 2;;
	--virt-install-opts)    VIRT_INSTALL_OPTS+=("$2"); shift 2;;
	--qemu-opts)
		if [[ "$2" =~ (^| )-cpu\ * ]]; then
			_cpuopt=$(echo "$2"|sed -r 's/.*((^| )-cpu [^ ]+).*$/\1/')
			_beside=$(echo "$2"|sed -r 's/.*((^| )-cpu [^ ]+).*$//')
			QEMU_CPU_OPT="--qemu-commandline=${_cpuopt# }"
			[[ -n "${_beside// /}" ]] && QEMU_OPTS+=("--qemu-commandline=${_beside}")
		else
			QEMU_OPTS+=("--qemu-commandline=$2")
		fi
		shift 2;;
	--qemu-env)      QEMU_ENV+=("--qemu-commandline=env=$2"); shift 2;;
	--qmp|--qemu-qmp)         QEMU_QMP="${2:-yes}"; shift 2;;
	--monitor|--qemu-monitor) QEMU_MONITOR="${2:-yes}"; shift 2;;
	--nested-kvm-on|--enable-guest-hy*)   ENABLE_L2VM=yes; shift 1;;
	--nested-kvm-off|--disable-guest-hy*) ENABLE_L2VM=no; shift 1;;
	-x) expectedRC=${2:-0}; expectedrc=$(expandrc ${expectedRC#=}); shift 2;;
	-v|--verbose)    let VERBOSE++; shift 1;;
	-q)              QUIET=yes; shift 1;;
	--reboot)        REBOOT=yes; shift 1;;
	--default-kernel) DEFAULT_KERNEL="$2"; shift 2;;
	-w|--wait)       WAIT=yes; WAIT_PORT="${2:-22}"; shift 2;;
	--win-*)
		WIN_AUTO=yes
		DEFAULT_DISK_BUS=sata
		WIN_TEMPLATE=${WIN_TEMPLATE:-base}
		WIN_IF_MODEL=${WIN_IF_MODEL:-e1000}
		case "$1" in
		--win-auto)		[[ -n "$2" ]] && WIN_TEMPLATE="${2}"; shift 2;;
		--win-uefi)		WIN_UEFI_OPT="--uefi"; shift 1;;
		--win-user)		WIN_USER="$2"; shift 2;;
		--win-passwd)		WIN_PASS="$2"; shift 2;;
		--win-wim-index)	WIN_WIM_IMAGE_INDEX="$2"; shift 2;;
		--win-openssh)		WIN_OpenSSH_OPT=("--openssh=$2"); shift 2;;
		--win-virtio-drv)	WIN_VirtioDrv_OPT=("--virtio-win=$2"); shift 2;;
		--win-key)		WIN_KEY_OPT="--product-key=$2"; shift 2;;
		--win-hostname)		WIN_HOSTNAME="$2"; shift 2;;
		--win-domain)		WIN_DOMAIN_OPT="--domain=$2"; shift 2;;
		--win-locale)		WIN_LOCALE_OPT="--locale=$2"; shift 2;;
		--win-enable-kdc)	WIN_KDC_OPT="--enable-kdc"; shift 1;;
		--win-dfs-target)	DFS=yes; DFS_TARGET="$2"; WIN_DFS_TARGET_OPT="--dfs-target=$2"; shift 2;;
		--win-ad-forest-level)	WIN_AD_FOREST_LEVEL_OPT="--ad-forest-level=$2"; shift 2;;
		--win-ad-domain-level)	WIN_AD_DOMAIN_LEVEL_OPT="--ad-domain-level=$2"; shift 2;;
		--win-parent-domain)	WIN_PARENT_DOMAIN_OPT="--parent-domain=$2"; shift 2;;
		--win-parent-ip)	WIN_PARENT_IP_OPT="--parent-ip=$2"; shift 2;;
		--win-download-url)	WIN_DL_URL_OPTS+=("--download-url=$2"); shift 2;;
		--win-run)		WIN_RUN_CMD_OPTS+=("--run=$2"); shift 2;;
		--win-run-post)		WIN_RUN_POST_CMD_OPTS+=("--run-post=$2"); shift 2;;
		--win-static-ip-ext)	WIN_STATIC_IP_EXT="$2"; shift 2;;
		--win-static-ip-int)	WIN_STATIC_IP_INT="$2"; shift 2;;
		--win-if-model)		WIN_IF_MODEL="$2"; CUSTOM_WIN_IF_MODEL=yes; shift 2;;
		*) shift;;
		esac
		;;
	--) shift; break;;
	esac
done

DownloadImagePath=${DownloadImagePath:-$ImagePath/download}

[[ ${#WIN_HOSTNAME} -gt 15 ]] && {
	echo -e "{VM:ERROR} length of windows hostname($WIN_HOSTNAME) should < 16" >&2
	exit 1
}

QEMU_KVM=$(PATH=/usr/libexec:$PATH command -v qemu-kvm 2>/dev/null)
if [[ "$GuestARCH" != "$HostARCH" || -z "$QEMU_KVM" ]]; then
	QEMU_KVM=$(PATH=/usr/libexec:$PATH command -v qemu-system-$GuestARCH 2>/dev/null)
	if [[ -z "$QEMU_KVM" && "$1" != prepare ]]; then
		echo -e "{VM:WARN} command 'qemu-kvm or qemu-system-$GuestARCH' not found" >&2
		echo -e "{VM:WARN} please run   \033[32msudo vm prepare\033[0m   first" >&2
		exit 2
	fi
fi
qemu_kvm_nvr() { echo -n ${QEMU_KVM} $(${QEMU_KVM} --version 2>/dev/null | awk '{print $4; exit}'); }
libvirt_nvr() { echo -n "libvirt-$(virsh --version 2>/dev/null)"; }
if [[ "${#NVDIMM_LIST[@]}" -gt 0 ]]; then
	if ! grep -q nvdimm < <(LANG=C $QEMU_KVM -device help 2>/dev/null); then
		echo -e "{VM:WARN} $(qemu_kvm_nvr) doesn't support nvdimm driver." >&2
		exit 1
	fi
fi
if [[ "${#NVME_DEVS[@]}" -gt 0 || -n "$NVME_BOOT" ]]; then
	if ! grep -q nvme < <(LANG=C $QEMU_KVM -device help 2>/dev/null); then
		echo -e "{VM:WARN} $(qemu_kvm_nvr) doesn't support nvme driver." >&2
		exit 1
	fi
fi
if [[ ${#SHARE_DIRS[@]} -gt 0 ]]; then
	if vercmp "$(libvirt_nvr)" lt libvirt-6.2; then
		echo -e "{VM:WARN} $(libvirt_nvr) doesn't support virtiofs driver that's required by --sharedir option." >&2
		exit 1
	fi
fi
if [[ ${#HOST_DEV_LIST[@]} -gt 0 ]]; then
	if [[ -z "$(ls $iommuGrpsRoot)" ]]; then
		kernelopts="intel_iommu=on iommu=pt"
		grep -q AuthenticAMD /proc/cpuinfo && kernelopts="amd_iommu=on"
		cat <<-MSG >&2
			{VM:WARN} iommu has not been enabled on your HOST, please change kernel options and reboot:"
			  sudo grubby --args="$kernelopts" --update-kernel=DEFAULT; sudo reboot
		MSG
		exit 1
	fi
fi

[[ "$QUIET" = yes ]] && {
	yumOpt=-q
	curlOpt=-s
}

# __main__
# check if support Virtualization
support_virtualization() {
	local rc=1
	case ${OSTYPE,,} in
	linux|linux-gnu*)
		case $(uname -m) in
		x86_64|amd64)
			grep -E -q -wo '(vmx|svm)' /proc/cpuinfo && rc=0;;
		aarch64|arm64)
			test -d /sys/module/kvm && rc=0;;
		*)
			echo "{VM:WARN} unsupported OS/platform." >&2;;
		esac
		;;
	freebsd)
		dmesg | grep -q -e VT-x: -e SVM: && rc=0;;
	*)
		echo "{VM:WARN} unsupported OS/platform." >&2;;
	esac
	return $rc
}
if ! support_virtualization; then
	echo -e "{VM:WARN} current machine doesn't support Virtualization, show help info with\n  $P -h" >&2
	exit 1
fi

is_slackware && export PATH=/usr/local/sbin:/usr/sbin:/sbin:$PATH
[[ "$1" = prepare ]] && {
	KISS_VM_READY=; ONLY_PREPARE=yes
	FORCE_PREPARE=$FORCE
	[[ -n "$CM_USER" ]] && {
		VMUSER=$CM_USER
		eval VMSHOME=~$VMUSER/VMs
		eval ImagePath=~$VMUSER/myimages
		eval perConfDir=~$VMUSER/.config/${_repon}
		eval oldperConfDir=~$VMUSER/.config/kiss-vm
	}
}
[[ "$KISS_VM_READY" != yes ]] && {
	if [[ -t 1 ]]; then
		prepare_kiss_vm $FORCE_PREPARE &>/dev/tty
	else
		#echo -e "{VM:WARN} there's not /dev/tty file redirect prepare_kiss_vm msg to stderr" >&2
		prepare_kiss_vm $FORCE_PREPARE >&2
	fi
	[[ "$ONLY_PREPARE" = yes ]] && exit
}

enable_nested_kvm() {
	if [[ "$OSTYPE" = linux* ]]; then
		local kmodule=$(lsmod|awk '$1 == "kvm" {print $NF}')
		local vendor=${kmodule#kvm_}

		{
		echo "options kvm-$vendor nested=1"

		[[ "$vendor" = intel ]] && cat <<-EOF
		options kvm-$vendor enable_shadow_vmcs=1
		options kvm-$vendor enable_apicv=1
		options kvm-$vendor ept=1
		EOF
		} | sudo tee /etc/modprobe.d/kvm-nested.conf >/dev/null

		if [[ $(< /sys/module/$kmodule/parameters/nested) != [Yy1] ]]; then
			modprobe -r $kmodule || {
				echo -e "{VM:WARN} stop tasks are using module $kmodule, and try again" >&2
				return 1
			}
			modprobe $kmodule
		fi
		cat /sys/module/$kmodule/parameters/nested
	fi
}
[[ "$ENABLE_NESTED" = yes ]] && {
	enable_nested_kvm
	exit $?
}

GuestARCH=${GuestARCH:-$HostARCH}
if [[ "$GuestARCH" = "$HostARCH" ]]; then
	virtualizationOption=--hvm
	[[ -n "$VIRT_TYPE" ]] && virtualizationOption=--virt-type=${VIRT_TYPE}
	case "$HostARCH" in
	(aarch64)
		virtualizationOption=
		[[ -z "$MACHINE_OPT" ]] && { MACHINE_OPT="--machine=virt"; MACHINE_QEMUOPT="-machine virt"; }
		if [[ -z "$QEMU_CPU" && -z "$VIRT_CPU" ]]; then
			#verified on 'Fedora-38/Ampere(R) Altra(R) Max Processor M128-30 CPU @ 3.0GHz'
			VIRT_CPU_OPT=--cpu=host
			if grep -q Asahi /etc/os-release; then
				#verified on 'Fedora-38 Asahi Remix/M2 MacBook'
				VIRT_CPU_OPT=--cpu=cortex-a76
			fi
		fi
		;;
	esac
else
	virtualizationOption=--virt-type=${VIRT_TYPE:-qemu}
	VirtInstallTimeOut=1200
	_QEMU_KVM=qemu-system-${GuestARCH}
	case "$GuestARCH" in
	(aarch64)
		#set default qemu cpu type cortex-a72 for aarch64, it works on RHEL aarch64 build
		[[ -z "$MACHINE_OPT" ]] && { MACHINE_OPT="--machine=virt"; MACHINE_QEMUOPT="-machine virt"; }
		if [[ -z "$QEMU_CPU" && -z "$VIRT_CPU" ]]; then
			_cpu=$(LANG=C $_QEMU_KVM -cpu ? |& grep cortex-a | sort -Vru | head -1)
			VIRT_CPU_OPT=--cpu=${_cpu// /}
		fi
		;;
	(s390x|ppc*|loongarch*)
		#qemu-system-s390x doesn't support --video=sql on fedora-35
		[[ -z "$SPECIFIED_VIDEO" ]] && VIDEO_OPT="--video=virtio"
		;;
	(riscv*)
		[[ -z "$MACHINE_OPT" ]] && { MACHINE_OPT="--machine=virt"; MACHINE_QEMUOPT="-machine virt"; }
		[[ -z "$SPECIFIED_VIDEO" ]] && VIDEO_OPT=""
		[[ -z "$SPECIFIED_VCPUS" ]] && VCPUS=8
		;;
	esac
fi

if [[ -n "$QEMU_CPU_OPT" ]]; then
	_cpuHvFlags=$(qmp-query-cpu-model-expansion.sh hvflags machineOpt=${MACHINE_OPT#*=})
	QEMU_CPU_OPT=$(echo "${QEMU_CPU_OPT}"|sed -r "s/-cpu +[^ ]+/&,$_cpuHvFlags/")
	QEMU_OPTS+=("$QEMU_CPU_OPT")
fi

case "$GuestARCH" in
(s390*)
	_MSIZE=2048M
	;;
(loongarch*)
	edk2path=/usr/share/edk2/loongarch64  #require pkg: edk2-loongarch64.noarch
	BOOT_OPTS+=(--boot=loader=$edk2path/QEMU_EFI.fd,nvram=$edk2path/QEMU_VARS.fd)
	QEMU_OPTS+=('--qemu-commandline=-device nec-usb-xhci,id=xhci,addr=0x1b -device usb-tablet,id=tablet,bus=xhci.0,port=1 -device usb-kbd,id=keyboard,bus=xhci.0,port=2')
	CDROM_BUS_TYPE=usb
	CDROM_BUS_TYPE=scsi
	;;
esac

fuzzy_match_cpu_model_name() {
	local QEMU_CMD=$QEMU_KVM
	local modelname=${1%%,*}
	$QEMU_CMD $MACHINE_QEMUOPT -cpu ? | sed -rn '1,/^$/{/Available CPUs:/d; s/^x86 //; p}' |
		awk -v modelname=$modelname -v pat=".*${modelname,,}.*" '
		{
			M=$1
			if (M == modelname) {
				yes++
			} else if (tolower(M) ~ pat) {
				if (length(m) == 0 || length(m) >= length(M)) { m=M }
			}
		}
		END {
			if (yes) { print modelname } else { print m }
		}'
}
support_nested_kvm() {
	local rc=1
	if [[ "$OSTYPE" = linux* && "$HostARCH" = "$GuestARCH" ]]; then
		local kmodule=$(lsmod|awk '$1 == "kvm" {print $NF}')
		local paramf=/sys/module/$kmodule/parameters/nested

		if [[ -f $paramf && $(< $paramf) = [Yy1] ]]; then
			rc=0
		fi
	fi
	return $rc
}

run -as=$VMUSER mkdir -p $RuntimeTmp ${DownloadImagePath}

subcmd="$1"; shift;
case "$subcmd" in
	h|\?|help)		Usage|less; exit;;
	prepare)		prepare_kiss_vm force; exit $?;;
	enable-nested-vm)	enable_nested_kvm; exit $?;;
	create|creat)		Distro=$1;;
	r|rm|d|de|del*)		vmdelete "$@"; exit $?;;
	co|con|cons*)		vmconsole "$@"; exit $?;;
	port|port*)		vmport_available "$@"; exit $?;;
	l|lo|log*)		vmlogin "$@"; exit $?;;
	qmp)			vmqmp "$@"; exit $?;;
	mon|monitor)		vmmonitor "$@"; exit $?;;
	cpfrom|cpf*)		vmcopyfrom "$@"; exit $?;;
	cpto|cpt*)		vmcopyto "$@"; exit $?;;
	e|ex|ex*)		vmexec "$@"; exit $?;;
	ls|li|lis|list)		vmlist "$@"; exit $?;;
	if|ifa*|ifaddr)		vmifaddr "$@"; exit $?;;
	ifl*|iflist)		vmiflist "$@"; exit $?;;
	if.un*|if.unplug)	vmifunplugin "$@"; exit $?;;
	if.pl*|if.plug)		vmifplugin "$@"; exit $?;;
	vi|vie|view*)		vmviewer "$@"; exit $?;;
	vn|vnc|vncp*)		vmvncproc "$@"; exit $?;;
	x|xm*)			vmxml "$@"; exit $?;;
	ed|ed*)			vmedit "$@"; exit $?;;
	restart|reboot|reb|re*)	vmreboot "$@"; exit $?;;
	stop|sto*)		vmstop "$@"; exit $?;;
	start|star*)		vmstart "$@"; exit $?;;
	autostart|autostar*)	vmautostart "$@"; exit $?;;
	noautostart|noautosta*)	vmnoautostart "$@"; exit $?;;
	stat)			vmstat "$@"; exit $?;;
	blk*|srcfiles)		_vmblklist "$@"; exit $?;;
	rootdir)		vmrootdir "$@"; exit $?;;
	homedir)		vmhomedir "$@"; exit $?;;
	clone)			vmclone "$@"; exit $?;;
	add.iso)		vmadd_iso "$@"; exit $?;;
	add.disk)		vmadd_disk "$@"; exit $?;;
	add.if)			vmadd_if "$@"; exit $?;;
	add.if.direct)		vmadd_if_direct "$@"; exit $?;;
	add.if.bridge)		vmadd_if_bridge "$@"; exit $?;;
	add.if.hostif)		vmadd_if_hostif "$@"; exit $?;;
	add.if.passthr*)	vmadd_if_passthr "$@"; exit $?;;
	passthr*)		vmpassthr "$@"; exit $?;;
	netls)			netls "$@"; exit $?;;
	net|netcreat*)		netcreate "$@"; exit $?;;
	netinfo)		netinfo "$@"; exit $?;;
	netstart)		netstart "$@"; exit $?;;
	netdel|netdelete)	netdelete "$@"; exit $?;;
esac

support_nested_kvm && ENABLE_L2VM=${ENABLE_L2VM:-yes}
kmodule=$(lsmod|awk '$1 == "kvm" {print $NF}')
cpuvendor=${kmodule#kvm_}
case $cpuvendor in (intel) flag=+vmx;; (amd) flag=+svm;; (*) flag=+fixme;; esac
if [[ "$ENABLE_L2VM" = yes ]]; then
	#[[ -z ${VIRT_CPU} || ${VIRT_CPU} = host* ]] && { apicflags=$(lscpu | grep -Ewo '(x2)?apic' | sed s/^/+/ | paste -s -d,); }
	apicflags=$(lscpu | grep -Ewo '(x2)?apic' | sed s/^/+/ | paste -s -d,)
	[[ -n "${apicflags}" ]] && flag+=,${apicflags}
	if [[ -z ${VIRT_CPU} ]]; then
		VIRT_CPU_OPT=--cpu=host-passthrough,$flag
	fi
else
	if [[ -z ${VIRT_CPU} ]]; then
		VIRT_CPU_OPT=${VIRT_CPU_OPT//,$flag/}
	fi
fi

VCPUN=$(vcpuN "$VCPUS")

[[ $(id -u) = 0 && -n "$SUDO_USER" ]] && {
	sshKeyOpts=$(for keyf in {$VMUSERHOME,/root}/.ssh/id_*; do [[ $keyf != *.pub ]] && echo -n "-i $keyf "; done)
}

run_with_newgrp() {
	expect <(cat <<-'EOF'
	set timeout -1
	log_user 0
	set cmdline {*}${argv}
	spawn -noecho newgrp libvirt
	expect "*\[>\$]" { send ": newgrp libvirt; ${cmdline}; exit \$?\r"; interact; }
	foreach {pid spawnid os_error_flag value} [wait] break
	exit $value
	EOF
	) "$(getReusableCommandLine "${@}")"
	exit $?
}

# Phase-0 process distro name
dbfile=${_confdir}/distro-db.bash
owndbfile=$perConfDir/distro-db.bash
shopt -s extglob
decodeDistro() {
	local d="$1"
	if [[ "$Intranet" = yes ]]; then
		if [[ "$bootc" == yes ]]; then
			if [[ "$d" =~ ^[0-9.]+n?$ ]]; then
				echo "{debug} expanding DISTRO pattern: $d (bootc mode) ..." >&2
				bootcTo=$(skopeo list-tags --retry-times 16 docker://images.paas.redhat.com/bootc/rhel-bootc |
					jq -r '.Tags[]' | grep RHEL-${d%n} | tail -1)
				Distro=$(skopeo inspect --retry-times 16 docker://images.paas.redhat.com/bootc/rhel-bootc:$bootcTo |
					jq -r '.Labels["redhat.compose-id"]')
				if [[ -z "$Distro" ]]; then
					echo "{warn} expanding DISTRO pattern: $d fail" >&2
				fi
			fi
		else
			echo "{debug} expanding DISTRO pattern: $d ..." >&2
			case ${d%[rn]} in
			(5) Distro=RHEL5-Server-U11;; (6) Distro=RHEL-6.10;;
			(7) Distro="RHEL-7.9-updates-????????.[0-9]+";;
			(7.+([0-9])) Distro="RHEL-${d}-updates-????????.[0-9]+";;
			(8|9) Distro="rhel-${d%[rn]}.[0-9]+.[0-9]+-????????.[0-9]+";;
			(1[0-9]) Distro="rhel-${d%[rn]}.[0-9]+-????????.[0-9]+";;
			(@(8|9).+([0-9])) Distro="RHEL-${d}.[0-9]-updates-????????.[0-9]+";;
			(@(1[0-9]).+([0-9])) Distro="RHEL-${d}-updates-????????.[0-9]+";;
			(fedora) Distro="Fedora-[0-9]+";;
			esac
			[[ ${d} = *r ]] && case ${d%r} in (8|9|1[0-9]) Distro="rhel-${d%r}.[0-9]+.[0-9]+";; esac
		fi
	else
		case ${d%[rn]} in
		(6|7) Distro="CentOS-${d%[rn]}";;
		(8|9|1[0-9]) Distro="CentOS-${d%[rn]}-stream";;
		(fedora) source $dbfile; Distro="f$lstv";;
		esac
	fi
}
[[ -z "$Distro" ]] && Distro=$1
[[ $Distro =~ ^[0-9]+(\.[0-9]+)?[rn]?$ || $Distro = fedora ]] && { decodeDistro $Distro; }
shopt -u extglob

#run with newgrp if new added group libvirt has not applied
if [[ $(id -u) != 0 ]] && ! is_slackware && ! id | grep -E -qw libvirt; then
	if [[ -z "$Distro" ]]; then
		run_with_newgrp $P "${orig_at[@]}"
	else
		run_with_newgrp $P "${orig_at[@]}" > >(awk 'NR>2 {print last} {last=$0}')
	fi
fi

[[ -n "$VNCPUTS" || -n "$VNCGET" || -n "$VNCGETSC" ]] && { vmvncproc "$@"; exit $?; }

LANG=C
declare -A distroInfo
if [[ $Intranet = yes ]]; then
	export TIME_SERVER=${TIME_SERVER:-clock.redhat.com}
else
	baseUrl=https://raw.githubusercontent.com/tcler/kiss-vm-ns/master

	#https://gist.github.com/mutin-sa/eea1c396b1e610a2da1e5550d94b0453
	export TIME_SERVER=${TIME_SERVER:-3.fedora.pool.ntp.org}
	#export TIME_SERVER=${TIME_SERVER:-time.windows.com}
	#export TIME_SERVER=${TIME_SERVER:-0.fedora.pool.ntp.org}
	#export TIME_SERVER=${TIME_SERVER:-1.fedora.pool.ntp.org}
	#export TIME_SERVER=${TIME_SERVER:-2.fedora.pool.ntp.org}
fi

[[ -f $dbfile ]] && {
	echo "{VM:INFO} load distro-db file $dbfile ..."
	source $dbfile
}
[[ -f $owndbfile ]] && {
	echo "{VM:INFO} load own distro-db file $owndbfile ..."
	source $owndbfile
}

for disk in "${EXTRA_DISKS[@]}"; do
	read size fstype _ <<<"${disk//,/ }"
done

#get distro name in interactive mode if not specified
#thanks: https://stackoverflow.com/questions/49733211/bash-jump-to-bottom-of-terminal
# { echo -ne "\E[${LINES};0H"; }  works the same as { tput cup $(tput lines) 0; }
distroSelectNull() { tput cup $(tput lines) 0; echo -e "\n{VM:WARN} ^^^ you didn't select any distro/family, it is necessary!" >&2; }
[[ -z "$Distro" ]] && {
	if [[ -z "$Location" && -z "$Imageurl" && -z "$Isourl" ]]; then
		distropatternInter=$RuntimeTmp/distroPatternInternet
		distropatternIntra=$RuntimeTmp/distroPatternIntranet
		distrolist=$RuntimeTmp/distroList
		dialogres=$RuntimeTmp/dialogRes
		touch $distropatternInter $distropatternIntra

		echo -e "Alma\nRocky\nCentOS\nfedora\ndebian\nubuntu\nopenSUSE\narchlinux\nFreeBSD\nWindows" >>$distropatternInter
		for dname in "${!distroInfo[@]}"; do echo "$dname"; done | sort -rV >>$distrolist

		dialogTitle="vm-create"
		[[ "$Intranet" = yes ]] && {
			echo -e "Fedora\nRHEL-10\nRHEL-9\nRHEL-8\nRHEL-7\nRHEL-6\nRHEL5" >>$distropatternIntra
			fetch_distro_list >>$distrolist
			dialogTitle+=" Intranet"
		}

		familys=$(sed -e 's/.*/"&" "" 1/' $distropatternIntra $distropatternInter)
		dialog --backtitle "$dialogTitle" --radiolist "please selet distro family/pattern:" 22 40 20 $familys 2>$dialogres || { distroSelectNull; exit 0; }
		pattern=$(head -n1 $dialogres|sed 's/"//g')
		dList=$(sed -e '/ /d' -e 's/.*/"&" "" 1/' $distrolist|grep -E "${pattern/fedora/f[0-9]+}")
		[[ "$Intranet" = yes ]] && grep -F "$pattern" $distropatternIntra && {
			dialog --title "If include nightly build" \
				--backtitle "Do you want nightly build distros?" \
				--yesno "Do you want nightly build distros?" 7 60
			[[ $? = 1 ]] && dList=$(echo "$dList"|grep -E -v '\.[nd]\.[0-9]+"')
		}
		dialog --backtitle "$dialogTitle" --radiolist "please select distro:" 30 60 28 $dList 2>$dialogres || { distroSelectNull; exit 0; }
		Distro=$(head -n1 $dialogres|sed 's/"//g')
		[[ -z "$Distro" ]] && { distroSelectNull; exit 0; }
		tput cup $(tput lines) 0
	else
		Usage
		echo -e "\n{VM:WARN} ^^^ a distro name is necessary!\n" >&2
		exit 1
	fi
}

[[ -z "$Distro" ]] && {
	echo -e "{VM:WARN} you have to select a distro name or specified it by adding command line parameter:\n" >&2
	Usage
	exit 1
}

if grep -E --color=always "[~\!@#$^&=\":;|<>'\` ]" <<<"$Distro"; then
	echo -e "{VM:WARN} ^^^ invalid character[s] in distro name: '$Distro'" >&2
	exit 1
fi

if [[ "$InstallType" = location && "${DOWNLOAD_ONLY}" = yes ]]; then
	echo -e "{VM:WARN} --downloadonly is conflict with install mode: location" >&2
	exit 1
fi

#set default disk bus to sata if distro is arch linux
[[ "${Distro,,}" =~ arch* ]] && { DEFAULT_DISK_BUS=sata; }

[[ "${*,,} ${Distro,,}" =~ windows ]] && {
	WIN_AUTO=yes
	DEFAULT_DISK_BUS=sata
	WIN_TEMPLATE=${WIN_TEMPLATE:-base}
	WIN_IF_MODEL=${WIN_IF_MODEL:-e1000}
}
[[ "$NOAUTO" = yes ]] && { WIN_AUTO=no; }
[[ "${Distro,,}" = fedora* || "${Distro,,}" =~ ^f[0-9]+$ ]] && { UEFI=yes; }
if [[ "$VM_OS_VARIANT" = win11 || "${*,,}" =~ (win|windows-?)11 ]]; then
	UEFI_TPM_SB=yes
fi
if [[ "$UEFI_TPM_SB" = yes ]]; then
	BOOT_OPTS+=(--boot=firmware=efi,loader_secure=yes)
	VTPM=yes
	[[ "$GuestARCH" = x86_64 ]] && { MACHINE_OPT="--machine=q35"; MACHINE_QEMUOPT="-machine q35"; }
elif [[ "$UEFI" = yes ]]; then
	BOOT_OPTS+=(--boot=uefi)
	[[ "$GuestARCH" = x86_64 ]] && { MACHINE_OPT="--machine=q35"; MACHINE_QEMUOPT="-machine q35"; }
fi

case "${BOOT_OPTS[*]}" in
(*uefi*|*firmware=efi*)
	if [[ -z "$NVME_BOOT" ]]; then
		VNCWAIT_AFTER_INSTALL+=("boot.manager,key:enter key:down key:down key:enter key:enter key:enter")
	else
		VNCWAIT_AFTER_INSTALL+=("boot.manager,key:enter key:down key:down key:enter key:down key:enter key:enter")
	fi
	;;
esac

if [[ -n "$BOOT_DISK_ATTRS" ]]; then
	[[ "$BOOT_DISK_ATTRS" =~ bus= ]] || BOOT_DISK_ATTRS+=,bus=${DISK_BUS:-$DEFAULT_DISK_BUS}
else
	BOOT_DISK_ATTRS=bus=${DISK_BUS:-$DEFAULT_DISK_BUS}
fi

if [[ "$VTPM" = yes ]]; then
	_dependpkgs=swtpm-tools
	_dependcmd=swtpm_setup
	if ! grep -q tpm-crb < <(LANG=C $QEMU_KVM -device help); then
		echo -e "{VM:WARN} $(qemu_kvm_nvr) don't support tpm-crb driver that's required by --vtpm option" >&2
		exit 1
	fi
	if ! command -v $_dependcmd &>/dev/null; then
		echo -e "{VM:WARN} pkg $_dependpkgs is/are needed by vTPM function, please install $_dependpkgs first." >&2
		exit 1
	fi
	VTPM_OPT="--tpm emulator,model=tpm-crb,version=2.0"
	PKGS+=" tpm2-tools"
fi

QXL_available() {
	local rc=0 qemu_kvm=$1
	[[ -z "$qemu_kvm" ]] && qemu_kvm=$(PATH=/usr/libexec:$PATH command -v qemu-kvm 2>/dev/null)

	local qemu_ver=$($qemu_kvm --version|awk '{print $4; exit}')
	[[ "$qemu_ver" < 6 ]] && { return 1; }

	local quietOpt=; [[ -z "$2" ]] && quietOpt=-q
	for ((i=0;i<4;i++)) do DISPLAY= LANG=C timeout 0.5 $qemu_kvm -vga qxl $MACHINE_QEMUOPT 2>&1; done |
		grep $quietOpt "${2:-QXL VGA not available}" && rc=1
	return $rc
}

[[ -n "$QEMU_KVM" ]] && {
	QXL_available $QEMU_KVM || {
		[[ -z "$SPECIFIED_VIDEO" && "$VIDEO_OPT" = *=qxl ]] && VIDEO_OPT=""
	}
	LANG=C $QEMU_KVM -machine help|grep -q q35 && Q35=support
}
[[ "$GuestARCH" = x86_64 && "$MACHINE_OPT" = *q35* && "$Q35" != support ]] && {
	echo -e "{VM:ERROR} Guest require machine type 'q35', but the qemu in your platform doesn't support 'q35'" >&2
	exit 1
}

[[ "$Distro" = *[][%*?+]* ]] && {
	dpattern=${Distro//./\\.}
	dpattern=${dpattern//\?/.}
	dpattern=${dpattern//[%*]/.*}
	_distro=$(fetch_distro_list | grep -i -E "^${dpattern}$" | head -1)
	[[ -n "$_distro" ]] && Distro="$_distro"
}

[[ "$OnlyGetVMName" = yes ]] && {
	vmname_gen $Distro $VMName
	exit $?
}

[[ -z "${OnlyGetUrl}" && "${DOWNLOAD_ONLY}" != yes ]] && {
	# check if VM exist
	vmname=$(vmname_gen $Distro $VMName)
	virsh desc $vmname &>/dev/null && {
		if [[ "${OVERWRITE}" = "yes" ]]; then
			echo "{VM:INFO} VM $vmname has been there, remove it ..."
			_vmdelete $vmname || {
				echo "{VM:ERR} delete $vmname fail, exit." >&2
				exit 2
			}
		elif [[ "${DOWNLOAD_ONLY}" != "yes" ]]; then
			echo "{VM:INFO} VM $vmname has been there, if you want overwrite please use --force option"
			exit
		fi
	}
	#vmhostname=${vmname%_${GuestARCH}}; vmhostname=${vmname#${VMUSER}-}
	vmhostname=${vmname}

	VMpath=$VMSHOME/$Distro/$vmname
	[[ "$InstallType" = pxe ]] && VMpath=$VMSHOME/PXE/$vmname
	create_vmhome $VMpath
	if [[ "$VMSHARE" != yes ]]; then
		setfacl -d -mg::--- -mo::--- $VMpath
	fi
}
if [[ "$VM_OS_VARIANT" = win* || "${VMpath,,}" =~ (win|windows(-server)?)-?[0-9] ]]; then
	_MSIZE=4096M
	[[ "$dsizeflag" -ne 1 ]] && DSIZE=80

	#add virtio-win iso
	if [[ "${EXTRA_CDROMS[*]}" != *virtio-win*.iso* ]]; then
		VirtioDriverISOUrl=/usr/share/virtio-win/virtio-win.iso
		if [[ -f "$VirtioDriverISOUrl" ]]; then
			#q35 support multi-cdrom
			#if not q35, extra cdrom will cause err: "boot failed : could not read from CDROM(code 0004)"
			#`-> see also: https://marc.info/?l=centos&m=151039100602440&w=2
			if [[ "$Q35" = support ]] && [[ -z "$MACHINE_OPT" || "$MACHINE_OPT" = *q35* ]]; then
				EXTRA_CDROMS+=("$VirtioDriverISOUrl")
			elif [[ -z "$WIN_VirtioDrv_OPT" ]]; then
				WIN_VirtioDrv_OPT="--virtio-win=$VirtioDriverISOUrl"
			fi
		fi
	fi
fi

for ((i=0; i<${#BOOT_OPTS[@]}; i++)); do
	bootopt=${BOOT_OPTS[$i]}
	if [[ "${bootopt}" = *nvram=* ]]; then
		nvramfpath=$(echo "${bootopt}"|sed -r 's/.*nvram=([^,]+).*/\1/')
		nvramfname=${nvramfpath##*/}
		cp $nvramfpath $VMpath/.
		BOOT_OPTS[$i]=$(echo "$bootopt"|sed "s|=$nvramfpath|=$VMpath/$nvramfname|")
		chcon system_u:object_r:qemu_var_run_t:s0 $VMpath/$nvramfname 2>/dev/null #system_u:object_r:virt_cache_t:s0 also works
		chmod a+r $VMpath/$nvramfname
	fi
	bootopt=${BOOT_OPTS[$i]}
	if [[ "${bootopt}" = *loader=* ]]; then
		biosfpath=$(echo "${bootopt}"|sed -r 's/.*loader=([^,]+).*/\1/')
		biosfname=${biosfpath##*/}
		cp $biosfpath $VMpath/.
		BOOT_OPTS[$i]=$(echo "$bootopt"|sed "s|=$biosfpath|=$VMpath/$biosfname|")
		chcon system_u:object_r:qemu_var_run_t:s0 $VMpath/$biosfname 2>/dev/null #system_u:object_r:virt_cache_t:s0 also works
		chmod a+r $VMpath/$biosfname
	fi
done

# Phase-1: get distro's Location or Image url
_Imagepattern='(qcow2c|qcow2|qcow2.xz|raw|raw.xz|img)'
[[ -n "${distroInfo[$Distro]}" ]] && {
	echo -e "{VM:INFO} db: ${distroInfo[$Distro]}"
	read _Imageurl _Location <<<"${distroInfo[$Distro]}"
	[[ "$_Imageurl" = *%%* ]] && {
		read _Imageurl _Imagepattern <<<"${_Imageurl/\%\%/ }"
	}
	if [[ "$_Imageurl" = cdrom:* ]]; then
		InstallType=cdrom_image
		Isourl=${Isourl:-${_Imageurl#cdrom:}}
		Imageurl=
	else
		echo -e "{VM:INFO} db: $_Imageurl($_Imagepattern) $_Location"

		[[ -z "$Imageurl" ]] && Imageurl=${_Imageurl}
		[[ -z "$Location" ]] && Location=${_Location}
	fi
}

if [[ "$InstallType" = import ]]; then
	if [[ -n "$Imageurl" ]]; then
		if [[ ! -f "$Imageurl" && ! -b "$Imageurl" ]]; then
			if ! is_available_url $Imageurl; then
				echo "{VM:WARN} '$Imageurl' is neither an image file nor an available url, exit .." >&2
				cleanup_and_exit 2
			else
				: #do nothing
			fi
		fi

		if [[ $Intranet = yes ]]; then
			if [[ $Distro = RHEL-* || $Distro = Fedora-* ]]; then
				Location=$(distro2location $Distro 2>/dev/null)
			fi
		fi
	else
		if [[ $Intranet != yes ]]; then
			echo "{VM:WARN} can not find imageUrl of '$Distro' in database." >&2
			cleanup_and_exit 1
		else
			echo "{VM:INFO} getting fastest location of $Distro ..." >&2
			Location=$(distro2location $Distro)
			[[ -z "$Location" ]] && {
				echo "{VM:WARN} can not find location info of '$Distro'" >&2
				cleanup_and_exit 1
			}
			echo -e " -> $Location"
			echo "{VM:INFO} getting image url according location url ^^^ ..." >&2
			imageLocation=${Location/\/os\//\/images\/}
			[[ $Distro = Fedora-* ]] &&
				imageLocation=$(echo "$imageLocation" | sed -r 's;/[Ss]erver|Everything/;/Cloud/;')
			is_available_url $imageLocation ||
				imageLocation=${imageLocation/Cloud/CloudImages}
			read Imageurl _ < <(getimageurls $imageLocation "${_Imagepattern}"|sort -Vr)
			if [[ $? != 0 ]]; then
				if [[ "${DOWNLOAD_ONLY}" = yes ]]; then
					echo "{VM:WARN} can not find imageUrl of '${Distro}:${GuestARCH}' in database." >&2
					cleanup_and_exit 1 &>/dev/null
				else
					echo "{VM:INFO} can not find imageUrl of '${Distro}:${GuestARCH}' in database, switching to Location mode" >&2
				fi
				InstallType=location
				Imageurl=
			fi
		fi
	fi

	# if not swithed to Location mode
	if [[ "$InstallType" = import ]]; then
		if [[ ! -f "$Imageurl" && ! -b "$Imageurl" ]]; then
			if ! grep -E -q '\.(qcow2c|qcow2|qcow2.xz|raw|raw.xz|img)$' <<<"$Imageurl"; then
				ImageurlOrig=$Imageurl
				read Imageurl _ < <(getimageurls ${Imageurl} "${_Imagepattern}"|sort -Vr)
			fi
		fi

		if [[ -n "$Imageurl" ]]; then
			if [[ -n "$OnlyGetUrl" ]]; then
				echo -e "image url: $Imageurl"
			else
				echo -e "image url: \e[4m$Imageurl\e[0m"
			fi
		else
			echo "{VM:WARN} not found '$GuestARCH' image from '${ImageurlOrig}' by pattern(${_Imagepattern})" >&2
			cleanup_and_exit 1
		fi
	fi
fi

if [[ "$InstallType" = location ]]; then
	_MSIZE=2048M

	if [[ $Intranet = yes && -z "$Location" ]]; then
		echo "{VM:INFO} getting fastest location of $Distro ..." >&2
		Location=$(distro2location $Distro)
	fi

	if [[ -n "$Location" ]]; then
		if [[ -n "$OnlyGetUrl" ]]; then
			echo -e "location url: $Location"
		else
			echo -e "location url: \e[4m$Location\e[0m"
		fi
	else
		echo "{VM:WARN} can not find distro location. please check if '$Distro' is valid distro" >&2
		cleanup_and_exit 1
	fi
fi

[[ -n "$OnlyGetUrl" ]] && { cleanup_and_exit &>/dev/null; }


if [[ "$InstallType" = pxe ]]; then
	_MSIZE=2048M
fi

available_gsize=$(LANG=C free -g | awk '/^Mem:/{print $NF}')
available_msize=$(LANG=C free -m | awk '/^Mem:/{print $NF}')
[[ "${_MSIZE%[Mm]}" -gt "$available_msize" ]] && _MSIZE=$((available_msize-8))M

MSIZE=${MSIZE:-$_MSIZE}
[[ "$MSIZE" = *[Gg] ]] || [[ ${MSIZE} =~ ^[0-9]+$ && ${MSIZE} -lt $available_gsize ]] &&
	MSIZE=$((${MSIZE%[Gg]} * 1024))
MSIZE=${MSIZE%[Mm]}

[[ "$MSIZE" -gt "$available_msize" ]] && {
	echo "{VM:ERR} the available mem size is less than that you required(${MSIZE}M)." >&2
	cleanup_and_exit 132
}
[[ "$MSIZE" -lt 256 ]] && {
	echo -e "\E[41m{VM:WARN} seems the mem size you required(${MSIZE}) is toooo small.\E[0m" >&2
	builtin read -p 'continue?[y/n](y) ' -t 10 ans
	[[ "$ans" = [Nn]* ]] && cleanup_and_exit 132
}

echo "{VM:INFO} guess/verify os-variant ..."
if [[ -z "$VM_OS_VARIANT" ]]; then
	VM_OS_VARIANT=${Distro/-/}
	VM_OS_VARIANT=${VM_OS_VARIANT%%-*}
	VM_OS_VARIANT=${VM_OS_VARIANT,,}

	osvariants=$(virt-install --os-variant list 2>/dev/null) ||
		osvariants=$(osinfo-query os 2>/dev/null)
	[[ -n "$osvariants" ]] && {
		grep -q "^ $VM_OS_VARIANT " <<<"$osvariants" || VM_OS_VARIANT=${VM_OS_VARIANT/.*/-unknown}
		grep -q "^ $VM_OS_VARIANT " <<<"$osvariants" || VM_OS_VARIANT=${VM_OS_VARIANT/[0-9]*/-unknown}
		if grep -q "^ $VM_OS_VARIANT " <<<"$osvariants"; then
			OS_VARIANT_OPT=--os-variant=$VM_OS_VARIANT
		fi
	}
	[[ -z "$OS_VARIANT_OPT" ]] && {
		LANG=C man virt-install 2>/dev/null|grep -q detect=on && OS_VARIANT_OPT=--os-variant=detect=on,require=off
	}
else
	OS_VARIANT_OPT=--os-variant=$VM_OS_VARIANT
fi

# Phase-2: start create VM
# prepare ssh pub key
[[ -f ~/.ssh/id_rsa && -f ~/.ssh/id_rsa.pub ]] || {
	echo -e 'y\n' | ssh-keygen -q -t rsa -f ~/.ssh/id_rsa -N ''
}
[[ -f ~/.ssh/id_ecdsa && -f ~/.ssh/id_ecdsa.pub ]] || {
	echo -e 'y\n' | ssh-keygen -q -t ecdsa -f ~/.ssh/id_ecdsa -N ''
}

kskey=inst.ks
case ${Distro,,} in
rhel-5*|rhel5*|centos5*|centos-5*)
	lerhel7=yes; kskey=ks
	EPEL=http://archive.fedoraproject.org/pub/archive/epel/epel-release-latest-5.noarch.rpm;;
rhel-6*|rhel6*|centos6*|centos-6*)
	lerhel7=yes; kskey=ks
	EPEL=http://dl.fedoraproject.org/pub/epel/epel-release-latest-6.noarch.rpm;;
rhel-7*|rhel7*|centos7*|centos-7*|anolis7*)
	lerhel7=yes;
	EPEL=http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm;;
rhel-8*|rhel8*|centos-8*|centos8*|rocky-8*|rocky8*|alma8*|alma-8*|anolis8*)
	EPEL=http://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm;;
rhel-9*|rhel9*|rocky-9*|rocky9*|alma9*|alma-9*|anolis9*)
	EPEL=http://dl.fedoraproject.org/pub/epel/epel-release-latest-9.noarch.rpm;;
rhel-1[0-9]*|rhel1[0-9]*|rocky-1[0-9]*|rocky1[0-9]*|alma1[0-9]*|alma-1[0-9]*|anolis1[0-9]*)
	EPEL=http://dl.fedoraproject.org/pub/epel/epel-release-latest-10.noarch.rpm;;
esac
[[ -n "$EPEL" ]] && PKGS="$EPEL $PKGS"

# prepare network option
gen_virt_mac() { echo -n 54:52:00$(od -txC -An -N3 /dev/random | tr \  :); }
if [[ "${#NETWORK_OPTS[@]}" -gt 0 ]]; then
	for ((i=0; i < ${#NETWORK_OPTS[@]}; i++)); do
		netopt=${NETWORK_OPTS[$i]}
		sif=$(sed -rn '/.*\<source=([^,]+)(,.*|$)/{s//\1/;p}' <<<"${netopt}")
		[[ -d /sys/class/net/$sif/wireless ]] && {
			echo -e "{VM:ERROR} '$sif': macvlan/macvtap does not work on wireless interface" >&2
			cleanup_and_exit 0
		}
	done
	if [[ "$WIN_AUTO" = yes ]]; then
		WIN_MAC_INT=$(gen_virt_mac); WIN_MAC_EXT=$(gen_virt_mac)
		NETWORK_OPTS[0]+=,mac=${WIN_MAC_EXT},model=${WIN_IF_MODEL}
		[[ -z "${NETWORK_OPTS[1]}" ]] && NETWORK_OPTS[1]=--network=network=default
		NETWORK_OPTS[1]+=,mac=${WIN_MAC_INT},model=${WIN_IF_MODEL}
	fi
	[[ "$lerhel7" = yes ]] &&  #change NIC order to ensure default ip route works on rhel7-
		[[ "${NETWORK_OPTS[1]}" =~ =direct, ]] && read NETWORK_OPTS[0] NETWORK_OPTS[1] <<< "${NETWORK_OPTS[1]} ${NETWORK_OPTS[0]}"
else
	is_bridge() { local ifname=$1; ip -d a s "$ifname" | grep -qw bridge; }
	srcif=$(get-default-if.sh)
	defaultFirstNetOpt="--network=type=direct,source=$srcif,source_mode=$MacvtapMode"
	is_bridge $srcif && defaultFirstNetOpt="--network=type=bridge,source=$srcif"
	[[ -d /sys/class/net/$srcif/wireless ]] && defaultFirstNetOpt="--network=network=kissaltnet"
	if [[ "$InstallType" = pxe ]]; then
		NETWORK_OPTS=("--network=type=direct,source=$srcif,source_mode=$MacvtapMode,model=${DEFAULT_IF_MODEL}")
		is_bridge $srcif && NETWORK_OPTS=("--network=type=bridge,source=$srcif,model=${DEFAULT_IF_MODEL}")
	elif [[ "$WIN_AUTO" = yes ]]; then
		WIN_MAC_INT=$(gen_virt_mac); WIN_MAC_EXT=$(gen_virt_mac)
		if [[ "$CUSTOM_WIN_IF_MODEL" = yes ]]; then
			intIfModel=${WIN_IF_MODEL}
		else
			case "$WIN_TEMPLATE" in (base) WIN_IF_MODEL=virtio;; esac
			intIfModel=e1000
		fi
		NETWORK_OPTS=("$defaultFirstNetOpt,mac=$WIN_MAC_EXT,model=${WIN_IF_MODEL}" "--network=network=default,mac=$WIN_MAC_INT,model=${intIfModel}")
		[[ "$lerhel7" = yes ]] &&  #change NIC order to ensure default ip route works on rhel7-
			NETWORK_OPTS=("--network=network=default,mac=$WIN_MAC_INT,model=${intIfModel}" "$defaultFirstNetOpt,mac=$WIN_MAC_EXT,model=${WIN_IF_MODEL}")
	else
		NETWORK_OPTS=("${defaultFirstNetOpt},model=${DEFAULT_IF_MODEL}" "--network=network=default,model=${DEFAULT_IF_MODEL}")
		[[ "$lerhel7" = yes ]] &&  #change NIC order to ensure default ip route works on rhel7-
			NETWORK_OPTS=("--network=network=default,model=${DEFAULT_IF_MODEL}" "${defaultFirstNetOpt},model=${DEFAULT_IF_MODEL}")
	fi
fi

get_ip_of_virt_network() { virsh net-dumpxml "$1" | sed -rn '/ *<ip.address=.([0-9.]+)..*/{s//\1/;p}'; }
if grep -q network=default <<<"${NETWORK_OPTS[*]}"; then
	defaultDNS=$(get_ip_of_virt_network default)
elif grep -q network=kissaltnet <<<"${NETWORK_OPTS[*]}"; then
	defaultDNS=$(get_ip_of_virt_network kissaltnet)
else
	netlist=$(grep -Eo 'network=network=[^ ,]+' <<<"${NETWORK_OPTS[*]}"|sed 's/.*=//')
	for net in $netlist; do
		if vm netinfo $net | xargs | grep -q =nat.*/dhcp; then
			defaultDNS=$(get_ip_of_virt_network $net)
			break
		fi
	done
fi

### hostdev option
HOST_DEV_OPTS=()
for dev in "${HOST_DEV_LIST[@]}"; do
	HOST_DEV_OPTS+=("--hostdev=$dev")
done
for nic in "${HOST_NIC_LIST[@]}"; do
	pcislot=$(nic2pcislot $nic)
	if [[ -n "$pcislot" ]]; then
		HOST_DEV_OPTS+=("--hostdev=$pcislot")
	else
		echo -e "{VM:WARN} host nic '$nic' is not a pci device" >&2
	fi
done

### xdisk option
k=0
for disk in "${EXTRA_DISKS[@]}"; do
	read size fstype _args <<<"${disk//,/ }"
	size=${size%[gG]}
	[[ $fstype = *=* ]] && { _args=$fstype; fstype=; }

	_format=qcow2
	_ximage=xdisk$((k++))
	if [[ -z "$fstype" ]]; then
		ximage=$_ximage.$_format
		qemu-img create -f qcow2 $VMpath/${ximage} ${size}G
	else
		_format=raw
		ximage=$_ximage.$_format
		if [[ "$VIRT_MKFS" = yes ]]; then
			#there are wrongs on filesystem that created by virt-make-fs
			virt-make-fs -v --partition --label=vmf_${_ximage} \
				-s ${size}G -t ${fstype} /usr/share/kiss-vm/fsroot.tgz $VMpath/${ximage}
		else
			create-vdisk.sh $VMpath/${ximage} ${size}G ${fstype} ${_ximage}
		fi
	fi
	[[ -z "$_args" ]] && _args=bus=${DISK_BUS:-$DEFAULT_DISK_BUS}
	DISK_OPTS+=" --disk path=$VMpath/${ximage},format=$_format,${_args}"  #bus=scsi
done

### disk option
for disk in "${DISKS[@]}"; do
	read img _args <<<"${disk/,/ }"
	if [[ ! -f "$img" && ! -b "$img" ]]; then
		echo -e "\n{VM:WARN} '--disk $disk': file '$img' does not exist, ignore it.\n" >&2
		continue
	fi

	[[ -z "$_args" ]] && _args=bus=${DISK_BUS:-$DEFAULT_DISK_BUS}
	[[ "$_args" != *format=* ]] && {
		_fmt=$(qemu-img info $img|awk '/file.format:/{print $NF}')
		[[ -n "$_fmt" ]] && _fmt=",format=$_fmt"
	}

	if [[ -f "$img" ]]; then
		cp -f $img $VMpath/.
		DISK_OPTS+=" --disk path=$VMpath/${img##*/},${_args}${_fmt}"
	elif [[ -b "$img" ]]; then
		DISK_OPTS+=" --disk path=${img},${_args}${_fmt}"
	fi
done

### xcdrom option
[[ ${#EXTRA_CDROMS[@]} > 0 && -z "$MACHINE_OPT" ]] && {
	#Q35 support multi-cdrom
	[[ "$Q35" = support ]] && { MACHINE_OPT="--machine=q35"; MACHINE_QEMUOPT="-machine q35"; }
}
for _iso in "${EXTRA_CDROMS[@]}"; do
	isopath=$VMpath/${_iso##*/}
	cp -v $_iso $isopath
	#fixme: ^^ performance improve?
	chcon system_u:object_r:qemu_var_run_t:s0 $isopath 2>/dev/null #system_u:object_r:virt_cache_t:s0 also works
	ls -lhZ $isopath
	DISK_OPTS+=" --disk $isopath,device=cdrom,${iso_bus_type:-bus=sata}"
done

### nvme option
c=1
for devinfo in "${NVME_DEVS[@]}"; do
	for attr in ${devinfo//,/ }; do
		case $attr in
		size=*|[0-9]*) fsize=${attr#size=};;
		format=*) format=${attr#format=};;
		esac
	done
	format=${format:-qcow2}
	devfile=nvme$c.$format
	qemu-img create -f $format $VMpath/$devfile ${fsize}G
	setfacl -mu:${QEMU_USER}:rwx -mg:${QEMU_USER}:rwx $VMpath/$devfile
	chcon system_u:object_r:qemu_var_run_t:s0 $VMpath/$devfile 2>/dev/null #system_u:object_r:virt_cache_t:s0 also works
	getfacl $VMpath/$devfile
	ls -lZ $VMpath/$devfile
	QEMU_OPTS+=("--qemu-commandline=-drive file=$VMpath/$devfile,format=$format,if=none,id=NVME$c -device nvme,drive=NVME$c,serial=nvme-$c,addr=$(printf 0x%x $((0x10+$c)))")
	let c++
done
LANG=C virt-install -h | grep -q -- --qemu-commandline || QEMU_OPTS=()

### nvdimm option
CONTROLLER_OPTS=
if [[ "${#NVDIMM_LIST[@]}" -gt 0 ]]; then
	[[ "$GuestARCH" = x86_64 ]] && {
		MACHINE_OPT="--machine=q35"; MACHINE_QEMUOPT="-machine q35";
		#see: https://www.kraxel.org/blog/2023/12/qemu-phys-bits
		lscpu|grep -q Address.sizes:\ *39 && VIRT_CPU_OPT=--cpu=EPYC-Milan,vendor=AuthenticAMD
	}
	CONTROLLER_OPTS="--controller=type=pci,index=9,model=pcie-root-port --controller=type=pci,index=10,model=pcie-root-port"

	hpmemMax=$((1024*512))   #units Mi
	memSlots=4
	MEM_OPTS="--memory=${MSIZE},hotplugmemorymax=$hpmemMax,hotplugmemoryslots=$memSlots --cpu cell0.cpus=0-$((VCPUN-1)),cell0.memory=$((MSIZE*1024))"

	nvdimmdevs=("${NVDIMM_LIST[@]}")
	for ((i=0; i<${#nvdimmdevs[@]}; i++)); do
		[[ $i -ge $memSlots ]] && break
		nvdimmfile=$VMpath/nvdimm-$i.dev
		read targetSize labelSize _ <<<"${nvdimmdevs[$i]//+/ }"
		targetSize=${targetSize:-511}
		labelSize=${labelSize:-1}
		totalSize=$((targetSize+labelSize))
		truncate -s ${totalSize}M $nvdimmfile
		MEM_OPTS+=" --memdev nvdimm,source_path=$nvdimmfile,target_size=${targetSize},target_node=0,target_label_size=${labelSize}"
	done
fi

### sharedir(virtio) option
if [[ ${#SHARE_DIRS[@]} -gt 0 ]]; then
	INTERACT=no
	MEM_OPTS+=" --memorybacking=access.mode=shared"

	hpmemMax=$((1024*512))   #units Mi
	memSlots=4
	MEM_OPTS+=" --memory=${MSIZE},hotplugmemorymax=$hpmemMax,hotplugmemoryslots=$memSlots --cpu cell0.cpus=0-$((VCPUN-1)),cell0.memory=$((MSIZE*1024))"

	#ref: https://libvirt.org/kbase/virtiofs.html#id3
	#- The host-side virtiofsd daemon, like other vhost-user backed devices,
	#- requires shared memory between the host and the guest.
	virsh allocpages 2M $((MSIZE/2))
	#or add memory_backing_dir = "/dev/shm/" in /etc/libvirt/qemu.conf
fi

MEM_OPTS=${MEM_OPTS:---memory=${MSIZE}}

### qemu qmp,monitor option
complete_qmp_mon_arg() {
	read _addr _ <<<"${1/,/ }"
	if ! grep -Er '^(unix|tcp):' <<<$_addr; then
		if grep -Eq '^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?):[0-9]+$' <<<$_addr; then
			_addr=tcp:$_addr
		elif grep -Eq '^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9]):[0-9]+$' <<<$_addr; then
			_addr=tcp:$_addr
		elif grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:[0-9]+$' <<<$_addr; then
			_addr=tcp:0.0.0.0:${_addr#*:}
		elif grep -Eq '^:?[0-9]+$' <<<$_addr; then
			_addr=tcp:0.0.0.0:${_addr#:}
		elif [[ -d "$(dirname $_addr)" ]]; then
			_addr=unix:$(readlink -f $_addr)
		else
			_addr=unix:$VMtmp/qmp.socket
		fi
	fi
	echo -n "$_addr,server,nowait"
}

#there's a issue: mknod unix socket fail on debian-12.5, so disable qmp by default on debian HOST
if command -v apt-get &>/dev/null; then QEMU_QMP=${QEMU_QMP}; else QEMU_QMP=${QEMU_QMP:-yes}; fi
[[ -n "$QEMU_QMP" ]] && {
	[[ "$QEMU_QMP" = yes ]] && QEMU_QMP=unix:$VMtmp/qmp.socket,server,nowait || {
		QEMU_QMP=$(complete_qmp_mon_arg $QEMU_QMP)
		echo -n "${QEMU_QMP%%,*}" >$VMtmp/qmp.${QEMU_QMP%%:*}
	}
	QEMU_QMP_OPT="-qmp ${QEMU_QMP}"
}
[[ -n "$QEMU_MONITOR" ]] && {
	[[ "$QEMU_MONITOR" = yes ]] && QEMU_MONITOR=unix:$VMtmp/monitor.socket,server,nowait || {
		QEMU_MONITOR=$(complete_qmp_mon_arg $QEMU_MONITOR)
		echo -n "${QEMU_MONITOR%%,*}" >$VMtmp/monitor.${QEMU_MONITOR%%:*}
	}
	QEMU_MONITOR_OPT="-monitor ${QEMU_MONITOR}"
}
[[ -n "$QEMU_QMP_OPT" || -n "$QEMU_MONITOR_OPT" ]] &&
	QEMU_QMP_MON_OPT=("--qemu-commandline=$QEMU_QMP_OPT $QEMU_MONITOR_OPT")

### start install
if [[ "$InstallType" = location ]]; then
	[[ -z "$KSPath" ]] && {
		echo "{VM:INFO} generating kickstart file for $Distro ..."
		ksauto=$VMpath/ks-$VM_OS_VARIANT-$$.cfg
		postscript=$VMpath/postscript.ks
		KSPath=$ksauto
		REPO_OPTS=$(distro2repos $Distro $Location | sed 's/^/--repo /')

		cat <<-END >>$postscript
		test -f /etc/yum.repo.d/cdn_os.repo && sed -i 's/enabled = 1/enabled = 0/' /etc/yum.repo.d/cdn_os.repo
		test -f /etc/dnf/dnf.conf && { test -f /usr/bin/yum || ln -s /usr/bin/{dnf,yum}; }

		echo "[\$USER@\${HOSTNAME} \${HOME} \$(pwd)] configure hostname ..."
		test -f /etc/hostname && echo ${vmhostname}.$VM_DOMAIN >/etc/hostname || echo HOSTNAME=${vmhostname}.$VM_DOMAIN >>/etc/sysconfig/network

		echo "[\$USER@\${HOSTNAME} \${HOME} \$(pwd)] yum install pkgs ${PKGS} ..."
		grep -q ^nameserver /etc/resolv.conf || { if=\$(ip -br a|tail -1|cut -d" " -f1); cn=\$(nmcli -g GENERAL.CONNECTION device show \$if); nmcli connection down "\${cn}"; systemctl restart NetworkManager; }
		yum --setopt=strict=0 install -y wget tmux ${PKGS} ipcalc 2>/dev/null

		END
		if [[ $Intranet = yes ]]; then
		cat <<-END >>$postscript
		echo "[\$USER@\${HOSTNAME} \${HOME} \$(pwd)] update ca trust ..."
		(cd /etc/pki/ca-trust/source/anchors && curl -Ls --remote-name-all https://certs.corp.redhat.com/{2022-IT-Root-CA.pem,2015-IT-Root-CA.pem,ipa.crt,mtls-ca-validators.crt,RH-IT-Root-CA.crt} && update-ca-trust)

		echo "[\$USER@\${HOSTNAME} \${HOME} \$(pwd)] getting taskfetch tools and brew-install $BPKGS ..."
		(cd /usr/bin && curl -k -Ls --remote-name-all $bkrClientImprovedUrl/utils/{brewinstall.sh,taskfetch.sh} $baseUrl/utils/srcrpmbuild.sh && chmod +x brewinstall.sh taskfetch.sh srcrpmbuild.sh)
		brewinstall.sh $(for b in $BPKGS; do echo -n "'$b' "; done) -noreboot
		[[ "$TASK_FETCH" = yes ]] && taskfetch.sh --install-deps

		echo "[\$USER@\${HOSTNAME} \${HOME} \$(pwd)] systemctl start restraintd ..."
		yum --setopt=strict=0 install -y restraint-rhts  beakerlib && systemctl start restraintd
		_rpath=share/restraint/plugins/task_run.d
		(cd /usr/\$_rpath && curl -k -Ls --remote-name-all $bkrClientImprovedUrl/\$_rpath/{25_environment,27_task_require} && chmod a+x *)
		(cd /usr/\${_rpath%/*}/completed.d && curl -k -Ls -O $bkrClientImprovedUrl/\${_rpath%/*}/completed.d/85_sync_multihost_tasks && chmod a+x *)

		END
		elif [[ "$TASK_FETCH" = yes ]]; then
		cat <<-END >>$postscript
		echo "[\$USER@\${HOSTNAME} \${HOME} \$(pwd)] getting taskfetch tools ..."
		(cd /usr/bin && curl -k -Ls -O $bkrClientImprovedUrl/utils/taskfetch.sh && chmod +x taskfetch.sh)
		taskfetch.sh --install-deps

		END
		fi

		[[ "$fips" = yes ]] && cat <<-END >>$postscript
		echo "[\$USER@\${HOSTNAME} \${HOME} \$(pwd)] enable fips ..."
		curl -o /usr/bin/enable-fips.sh -k -Ls $baseUrl/utils/enable-fips.sh
		chmod +x /usr/bin/enable-fips.sh
		enable-fips.sh

		END
		[[ "$kdump" = yes ]] && cat <<-END >>$postscript
		echo "[\$USER@\${HOSTNAME} \${HOME} \$(pwd)] kdump-setup ..."
		curl -o /usr/bin/kdump-setup.sh -k -Ls $baseUrl/utils/kdump-setup.sh
		chmod +x /usr/bin/kdump-setup.sh
		kdump-setup.sh
		END
		[[ "$GenerateImage" = yes ]] && {
			cat <<-END >>$postscript
			test -f /etc/yum.repo.d/cdn_os.repo && sed -i 's/enabled = 0/enabled = 1/' /etc/yum.repo.d/cdn_os.repo
			echo "[\$USER@\${HOSTNAME} \${HOME} \$(pwd)] install cloud-init ..."
			yum install -y cloud-init
			test -f /etc/yum.repo.d/cdn_os.repo && sed -i 's/enabled = 1/enabled = 0/' /etc/yum.repo.d/cdn_os.repo
			END
		}
		if [[ ! -f $Location ]]; then
			URL_OPT="-url $Location"
		fi
		if [[ "$NO_SSHKEY" = yes ]]; then
			ks-generator.sh -d $Distro $URL_OPT $REPO_OPTS $_REPO_OPTS --post $postscript \
				--kopts="$KOPTS" --pkgs=$KS_PKGS --only-use=$KS_OnlyUse --append="$KS_APPEND" \
				--netn ${#NETWORK_OPTS[@]} --default-dns=$defaultDNS $KS_FSTYPE_OPT >$KSPath
		else
			ks-generator.sh -d $Distro $URL_OPT $REPO_OPTS $_REPO_OPTS --post $postscript \
				--kopts="$KOPTS" --pkgs=$KS_PKGS --only-use=$KS_OnlyUse --append="$KS_APPEND" \
				--sshkeyf ~/.ssh/id_rsa.pub --sshkeyf ~/.ssh/id_ecdsa.pub \
				--netn ${#NETWORK_OPTS[@]} --default-dns=$defaultDNS $KS_FSTYPE_OPT >$KSPath
		fi
	}

	echo -e "{VM:INFO} creating VM by using location:\n ->  $Location"
	run -as=$VMUSER touch $VMpath/.kiss-vm
	run -as=$VMUSER bash -c "echo $Location >$VMpath/url"
	if [[ -f $Location ]]; then
		cp $Location $VMpath/. && Location=$VMpath/${Location##*/}
	fi

	[[ "$GenerateImage" = yes ]] && {
		sed -i '/^reboot$/s//poweroff/' ${KSPath}
		NOREBOOT=--noreboot
	}
	ksfile=${KSPath##*/}

	if [[ -n "$TO_DISK" ]]; then
		imagefile="$TO_DISK"
	else
		imagefile=$VMpath/${vmname}.qcow2
		qemu-img create -f qcow2 ${imagefile} ${DSIZE}G
	fi

	[[ "$DEBUG" = yes ]] && {
		echo "#[debug] kickstart:"
		cat ${KSPath}
	}

	ls -l ${imagefile}

	BOOT_DISK_OPT=
	if [[ -z "$NVME_BOOT" ]]; then
		BOOT_DISK_OPT="--disk path=${imagefile},${BOOT_DISK_ATTRS}"
	else
		BOOT_DISK_OPT="--disk none"
		setfacl -mu:${QEMU_USER}:rwx -mg:${QEMU_USER}:rwx $imagefile
		chcon system_u:object_r:qemu_var_run_t:s0 $imagefile 2>/dev/null #system_u:object_r:virt_cache_t:s0 also works
		QEMU_OPTS+=("--qemu-commandline=-drive file=$imagefile,format=qcow2,if=none,id=NVME0 -device nvme,drive=NVME0,serial=nvme-0,bootindex=-1,addr=0x10")
	fi

	#workaround: see Bug 1707389 #c15
	workaroundExtraArgs="rd.driver.pre=loop"
	LANGUAGE=C run -debug -nohup unbuffer virt-install --connect=qemu:///system $virtualizationOption --accelerate $XML \
	  --name $vmname \
	  $OS_VARIANT_OPT \
	  ${ARCH_OPT} \
	  $MACHINE_OPT \
	  --vcpus ${VCPUS} \
	  $MEM_OPTS \
	  --location $Location \
	  $BOOT_DISK_OPT \
	  "${BOOT_OPTS[@]}" \
	  $DISK_OPTS \
	  "${NETWORK_OPTS[@]}" \
	  $CONTROLLER_OPTS \
	  "${HOST_DEV_OPTS[@]}" \
	  --initrd-inject $KSPath \
	  --extra-args="$kskey=file:/$ksfile console=tty0 console=ttyS0,${baudrate}n8 $workaroundExtraArgs" \
	  $VTPM_OPT \
	  ${VIDEO_OPT} \
	  ${SOUND_OPT} \
	  $NOREBOOT \
	  --noautoconsole \
	  ${GRAPHICS_OPT:---graphics=${DEFAULT_GRAPHICS_CONF}} \
	  ${VIRT_CPU_OPT} \
	  "${VIRT_INSTALL_OPTS[@]}" \
	  "${QEMU_OPTS[@]}" "${QEMU_ENV[@]}" "${QEMU_QMP_MON_OPT[@]}"

	[[ -z "$XML" ]] && while true; do test -s $VMpath/nohup.log && break; done
	expect -c "spawn tail -f $VMpath/nohup.log
		set timeout $VirtInstallTimeOut
		expect {
			{* to complete the installation process.} { exit }
			{otherwise, please restart your installation} { exit }
			{</domain>} { exit }
			{ERROR } { exit }
			{*\r} { exp_continue }
		}
	"
	grep ^ERROR $VMpath/nohup.log && cleanup_and_exit 1
	[[ -n "$XML" ]] && {
		cp $VMpath/nohup.log $VMpath/vm.xml
		virsh domxml-to-native qemu-argv $VMpath/vm.xml | tee $VMpath/qemu-argv
		cleanup_and_exit &>/dev/null
	}

	if [[ "$NOAUTO" = yes ]]; then
		expect -c '
			set timeout 10
			spawn virsh console '"$vmname"'
			expect {
				timeout {
					send_user "\n\n{VM:INFO} exiting from console...\n"
					exit 0
				}
				exp_continue
			}
		'
	else
		trap - SIGINT
		for ((i=0; i<31; i++)); do
			#clear -x
			tput cup $(tput lines) 0
			INTERACT=$INTERACT LANG=C expect -c '
				set intc 0
				set timeout -1
				spawn virsh console '"$vmname"'
				trap {
					send_user "You pressed Ctrl+C [incr intc]/8\n"
					if {$intc >= 8} {
						interact; exit
					}
				} SIGINT
				expect {
					"error: Disconnected from qemu:///system due to end of file*" {
						send "\r"
						puts $expect_out(buffer)
						exit 5
					}
					"error: failed to get domain" {
						send "\r"
						puts $expect_out(buffer)
						exit 6
					}
					"error: internal error: character device console0 is not using a PTY" {
						send "\r"
						puts $expect_out(buffer)
						exit 1
					}
					"Unsupported Hardware Detected" {
						send "\r"
						exp_continue
					}
					"Which would you like to install through" {
						# see: [RHEL 6.1] Anaconda requires user interaction in case of kickstart network activation failing
						send "\r"
						interact; exit
					}

					"reboot: Power down" { exit 0 }
					"Power down" { exit 0 }

					"reboot: Restarting system" { send "\r"; exit 1 }
					"Restarting system" { send "\r"; exit 1 }

					"error: The domain is not running" { send "\r"; exit 127 }

					"reboot: System halted" { send_user "\r\rsomething is wrong! cancel installation ..\r\r"; exit 255 }
					"System halted" { send_user "\r\rsomething is wrong! cancel installation ..\r\r"; exit 255 }

					"An unknown error has occurred" { exit 255 }
					"error: Domain not found:" { exit 255 }

					"* login:" { send "root\r" }
				}
				expect "Password:" {
					send "'"$defaultPasswd"'\r"
					send {if ! grep -q ^nameserver /etc/resolv.conf; then ip r|awk '"'"'/^default/{print "nameserver", $3}'"'"' >>/etc/resolv.conf; }
					send {if=$(ip -br a|tail -1|cut -d" " -f1); cn=$(nmcli -g GENERAL.CONNECTION device show $if); nmcli connection down "${cn}"; systemctl restart NetworkManager; fi;}; send "\r\n"
					send {ip a s eth1 2>/dev/null | awk -v rc=1 -v RS= '"'"'/eth1/&&!/inet/{rc=0}END{exit rc}'"'"' && dhclient eth1 2>/dev/null;}; send "\r\n"
					send "\r\r\r\r\r\r"
					send "# you are in console, Ctr + ] to exit \r"
					expect -re {[>$#:] *$} { send "read -N 10000000 -t 0.001  #clear input buffer\r"; after 2 }
					send "\r\r\r\r\r\r"
				}

				if {$env(INTERACT) == "no"} { exit 0 }
				interact; exit
			'
			ReturnCode=$?
			[[ $ReturnCode = 0 || $ReturnCode = 255 ]] && break
			[[ $ReturnCode = 127 ]] && { virsh start $vmname 2>&1 | sed 's/error: //'; continue; }
			sleep 2
		done
		echo -e "\n{VM:INFO} Quit from expect -c 'spawn virsh console $vmname'"

		[[ $ReturnCode = 255 ]] && {
			echo -e "\n{VM:INFO} something is wrong(please check screen log), will clean all tmp files ..."
			RM=yes
			GenerateImage=
		}
	fi

elif [[ "$InstallType" = import ]]; then
	[[ -f $Imageurl ]] && Imageurl=file://$(readlink -f ${Imageurl})
	imagefilename=${Imageurl##*/}
	imagefile=$VMpath/$imagefilename
	dlimagefile=$imagefile
	[[ -n "$SAVE_IMAGE" || "$DOWNLOAD_ONLY" = yes ]] && dlimagefile=${DownloadImagePath%/}/${imagefilename}

	echo "{VM:INFO} downloading cloud image file of $Distro to $dlimagefile ..."
	if [[ -b "$Imageurl" ]]; then
		imagefile=$Imageurl
	elif [[ $Imageurl != file:///* ]]; then
		if [[ -n "$SAVE_IMAGE" ]]; then
			curl_download_x ${dlimagefile} $Imageurl
			[[ "$DOWNLOAD_ONLY" = yes ]] && {
				ls -l ${dlimagefile}
				cleanup_and_exit 0
			}
			cp ${dlimagefile} $imagefile
		else
			curl_download_x $imagefile $Imageurl
		fi
	else
		cp -vf ${Imageurl#file://} $imagefile
	fi
	[[ -f "${imagefile}" || -b "$imagefile" ]] || cleanup_and_exit 1

	[[ -f "${imagefile}" && $imagefile = *.xz ]] && {
		echo "{VM:INFO} decompress $imagefile ..."
		xz -d $imagefile
		rm -f $imagefile
		imagefile=${imagefile%.xz}
		[[ -f ${imagefile} ]] || cleanup_and_exit 1
	}

	if [[ "${Distro,,}" = windows* ]]; then
		NOAUTO=yes
		BOOT_OPTS+=(--boot=uefi)
		[[ "$GuestARCH" = x86_64 ]] && { MACHINE_OPT="--machine=q35"; }
	elif [[ "$NO_CLOUD_INIT" != yes ]]; then
		echo -e "{VM:INFO} creating cloud-init iso"
		cloudinitiso=$VMpath/$vmname-cloud-init.iso
		iso_bus_type=
		[[ "${Distro,,}" = debian* ]] && iso_bus_type=,bus=scsi
		[[ -n "${CDROM_BUS_TYPE}" ]] && iso_bus_type=,bus=${CDROM_BUS_TYPE}

		[[ "$fips" = yes ]] && FIPS_OPT=--fips
		[[ "$kdump" = yes ]] && KDUMP_OPT=--kdump
		[[ $Intranet = yes && -n "$Location" ]] && {
			REPO_OPTS=$(distro2repos $Distro $Location | sed -e '/cdn_os:/d' -e 's/^/--repo /')
		}
		[[ "$DEBUG" = yes ]] && DEBUG_OPT=--debug
		if [[ "$NO_SSHKEY" = yes ]]; then
			cloud-init-iso-gen.sh -d $Distro $cloudinitiso -hostname ${vmhostname}.$VM_DOMAIN -b "$BPKGS" \
				-p "$PKGS" $DEBUG_OPT $REPO_OPTS $_REPO_OPTS $FIPS_OPT $KDUMP_OPT --kopts="$KOPTS" \
				--default-dns=$defaultDNS
		else
			cloud-init-iso-gen.sh -d $Distro $cloudinitiso -hostname ${vmhostname}.$VM_DOMAIN -b "$BPKGS" \
				-p "$PKGS" $DEBUG_OPT $REPO_OPTS $_REPO_OPTS $FIPS_OPT $KDUMP_OPT --kopts="$KOPTS" \
				--sshkeyf ${VMUSERHOME}/.ssh/id_rsa.pub --sshkeyf ${VMUSERHOME}/.ssh/id_ecdsa.pub \
				--default-dns=$defaultDNS
		fi
		CLOUD_INIT_OPT="--disk $cloudinitiso,device=cdrom$iso_bus_type"
	fi

	echo -e "{VM:INFO} creating VM by import $imagefile"
	run -as=$VMUSER bash -c "touch $VMpath/.kiss-vm"
	run -as=$VMUSER bash -c "echo $Imageurl >$VMpath/url"

	if [[ -f "${imagefile}" ]]; then
		imginfo=$(qemu-img info ${imagefile})
		imgfmt=$(echo "${imginfo}"|awk -F': ' '/file format/{print $2}')
		[[ "$dsizeflag" = 1 || "$NOAUTO" != yes ]] && {
			_size=$(echo "${imginfo}"|sed -rn '/^virtual size:.*\(([0-9]+).*$/{s//\1/;p}')
			[[ "$_size" -lt $((DSIZE*1024*1024*1024)) ]] && {
				echo -e "{VM:INFO} resize $imagefile to ${DSIZE}G"
				qemu-img resize -f $imgfmt ${imagefile} ${DSIZE}G
			}
		}
		if [[ -n "$TO_DISK" ]]; then
			_fmt=$(qemu-img info $imagefile|awk '/file.format:/{print $NF}')
			qemu-img convert -f $_fmt -O raw $imagefile "$TO_DISK"
			imagefile="$TO_DISK"
		fi
	elif [[ -b "${imagefile}" ]]; then
		if [[ -n "$TO_DISK" ]]; then
			qemu-img convert -f raw -O raw $imagefile "$TO_DISK"
			imagefile="$TO_DISK"
		fi
	fi

	ls -l ${imagefile}

	BOOT_DISK_OPT=
	if [[ -z "$NVME_BOOT" ]]; then
		BOOT_DISK_OPT="--disk path=${imagefile},${BOOT_DISK_ATTRS}"
	else
		setfacl -mu:${QEMU_USER}:rwx -mg:${QEMU_USER}:rwx $imagefile
		chcon system_u:object_r:qemu_var_run_t:s0 $imagefile 2>/dev/null #system_u:object_r:virt_cache_t:s0 also works
		QEMU_OPTS+=("--qemu-commandline=-drive file=$imagefile,format=$imgfmt,if=none,id=NVME0 -device nvme,drive=NVME0,serial=nvme-0,bootindex=0,addr=0x10")
	fi

	LANGUAGE=C run -debug -nohup unbuffer virt-install --connect=qemu:///system $virtualizationOption --accelerate $XML \
	  --name $vmname \
	  $OS_VARIANT_OPT \
	  ${ARCH_OPT} \
	  $MACHINE_OPT \
	  --vcpus ${VCPUS} \
	  $MEM_OPTS \
	  --import \
	  $BOOT_DISK_OPT \
	  "${BOOT_OPTS[@]}" \
	  $DISK_OPTS \
	  $CLOUD_INIT_OPT \
	  "${NETWORK_OPTS[@]}" \
	  $CONTROLLER_OPTS \
	  "${HOST_DEV_OPTS[@]}" \
	  $VTPM_OPT \
	  ${VIDEO_OPT} \
	  ${SOUND_OPT} \
	  --noautoconsole \
	  ${GRAPHICS_OPT:---graphics=${DEFAULT_GRAPHICS_CONF}} \
	  ${VIRT_CPU_OPT} \
	  "${VIRT_INSTALL_OPTS[@]}" \
	  "${QEMU_OPTS[@]}" "${QEMU_ENV[@]}" "${QEMU_QMP_MON_OPT[@]}"

	[[ -z "$XML" ]] && while true; do test -f $VMpath/nohup.log && break; done
	expect -c "spawn tail -f $VMpath/nohup.log
		set timeout $VirtInstallTimeOut
		expect {
			{*Domain creation completed.} { exit }
			{otherwise, please restart your installation} { exit }
			{</domain>} { exit }
			{ERROR } { exit }
			{*\r} { exp_continue }
		}
	"
	grep ^ERROR $VMpath/nohup.log && cleanup_and_exit 1
	[[ -n "$XML" ]] && {
		cp $VMpath/nohup.log $VMpath/vm.xml
		virsh domxml-to-native qemu-argv $VMpath/vm.xml | tee $VMpath/qemu-argv
		cleanup_and_exit &>/dev/null
	}

	if [[ "$NOAUTO" = yes ]]; then
		expect -c '
			set timeout 10
			spawn virsh console '"$vmname"'
			expect {
				timeout {
					send_user "\n\n{VM:INFO} exiting from console...\n"
					exit 0
				}
				exp_continue
			}
		'
		if [[ -n "$VNCPUT_AFTER_INSTALL" ]]; then
			vm vnc "$vmname" -put "$VNCPUT_AFTER_INSTALL"
		else
			vm vnc "$vmname" -get
		fi

		echo -e "{VM:INFO} vnc info:"
		vm vnc $vmname
	else
		if grep -i -q freebsd <<<"$Distro"; then
			echo -e "{VM:INFO} waiting console info ..."
			SHUTDOWN=$GenerateImage LANG=C expect -c '
				set intc 0
				set timeout 32
				spawn virsh console '"$vmname"'
				trap {
					send_user "You pressed Ctrl+C [incr intc]/8\n"
					if {$intc >= 8} {
						interact; exit
					}
				} SIGINT

				expect {Escape character is ^] (Ctrl + ])} {}
				expect {
					"????:" {}
					timeout {
						send_user "\n\n{VM:INFO} waiting console timeout ...\n"
						exit 128
					}
				}

				set timeout -1
				expect "*login:" {
					send "root\n"
				}
				expect "*:~ #" {
					send {hostname '"${vmname}"';
echo hostname='"${vmname}"' >>/etc/rc.conf;
service syslogd reload;
echo sshd_enable=\"YES\" >>/etc/rc.conf;
printf "PermitRootLogin yes\nPasswordAuthentication yes\n" >>/etc/ssh/sshd_config;
grep "^[^#]" /etc/rc.conf /etc/ssh/sshd_config;
pw useradd foo -G wheel;
echo '"$defaultPasswd"' | pw usermod foo -h 0;
echo '"$defaultPasswd"' | pw usermod root -h 0;
/etc/rc.d/sshd start;}
					send "\r"
					send "echo _END_\r"
				}
				expect "_END_" { exit 0 }
			'
			if [[ $? = 128 ]]; then
				Console=no
				echo -e "{VM:INFO} waiting vnc login: prompt ..."
				Scrn=$(vm vnc "$vmname" -get)
				if [[ -n "$Scrn" && "$Scrn" != "Guest has not initialized the display"* ]]; then
					vm vnc "$vmname" -get
					while ! grep "^login:" < <(vm vnc "$vmname" -get); do sleep 10; done
					vm vnc "$vmname" -putln root
					vm vnc "$vmname" -putln "hostname ${vmname}" \
						-putln "echo 'hostname=\"${vmname}\"' >>/etc/rc.conf" \
						-putln "service syslogd reload" \
						-putln "echo 'sshd_enable=\"YES\"' >>/etc/rc.conf" \
						-putln "printf 'PermitRootLogin yes\\nPasswordAuthentication yes\\n' >>/etc/ssh/sshd_config" \
						-putln "grep '^[^#]' /etc/rc.conf" \
						-putln "grep '^[^#]' /etc/ssh/sshd_config"
					timeout 5 vm vnc "$vmname" -get
					vm vnc "$vmname" -putln "pw useradd foo -G wheel" \
						-putln "passwd foo" -put "" -putln "$defaultPasswd" -put "" -putln "$defaultPasswd" \
						-putln "passwd root" -put "" -putln "$defaultPasswd" -put "" -putln "$defaultPasswd" \
						-putln "/etc/rc.d/sshd start"
					timeout 5 vm vnc "$vmname" -get
				else
					vm vnc "$vmname" -get
					echo "{VM:ERR} Both Guest's console and vnc are not available." >&2
					exit 1
				fi
			fi

			read _vmaddr < <(vmifaddr "$vmname")
			if port_available "$_vmaddr" 22; then
				expect -c "
					spawn ssh-copy-id -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@$_vmaddr
					expect -re Password.for.*: {send \"$defaultPasswd\\r\"}
					expect eof
				"
			fi
			[[ "$INTERACT" != no ]] && {
				vmlogin $vmname
			}
		else
			trap - SIGINT
			for ((i=0; i<31; i++)); do
				INTERACT=$INTERACT SHUTDOWN=$GenerateImage LANG=C expect -c '
					set intc 0
					set timeout -1
					spawn virsh console '"$vmname"'
					trap {
						send_user "You pressed Ctrl+C [incr intc]/8\n"
						if {$intc >= 8} {
							interact; exit
						}
					} SIGINT
					expect {
						"error: failed to get domain" {
							send "\r"
							puts $expect_out(buffer)
							exit 6
						}
						"error: internal error: character device console0 is not using a PTY" {
							send "\r"
							puts $expect_out(buffer)
							exit 1
						}
						"dracut:/#" {
							send "\r"
							puts $expect_out(buffer)
							exit 1
						}
						"* login:" { send "root\r" }
					}
					expect "Password:" {
						send "'"$defaultPasswd"'\r"
						send "\r\r\r\r\r\r"
						expect {
							"* ~\]#" {}
							":~#" {}
							":~ #" {}
							"Login incorrect" {
								send_user "{warn} invalid user/password(root/'"$defaultPasswd"')\n"
								send_user "{warn} maybe your image file is not a cloud image\n"
								send_user "{warn} please get the right user/password\n"
								if {$env(INTERACT) == "no"} {
									exit 0
								} else {
									interact; exit 0
								}
							}
						}
						if {$env(SHUTDOWN) == "yes"} {
							send {sleep 16; while ps axf|grep -A1 "/var/lib/cloud/instance/scripts/runcm[d]"; do echo "{VM:INFO}: cloud-init scirpt is still running .."; sleep 10; done; poweroff}
							send "\r\n"
							expect "Restarting system" { exit 0 }
						}

						send {ip a s eth1 2>/dev/null | awk -v rc=1 -v RS= '"'"'/eth1/&&!/inet/{rc=0}END{exit rc}'"'"' && dhclient eth1 2>/dev/null;}; send "\r\n"
						send {sleep 16; while ps axf|grep -A1 "/var/lib/cloud/instance/scripts/runcm[d]"; do echo "{VM:INFO}: cloud-init scirpt is still running .."; sleep 10; done; echo "~~~~~~~~ no cloud-init or cloud-init done ~~~~~~~~"\d}
						send "\r\n"
						expect {
							-re "or cloud-init done ~~~~~~~~d" {
								send {if ! grep -q ^nameserver /etc/resolv.conf; then ip r|awk '"'"'/^default/{print "nameserver", $3}'"'"' >>/etc/resolv.conf; }
								send {if=$(ip -br a|tail -1|cut -d" " -f1); cn=$(nmcli -g GENERAL.CONNECTION device show $if); nmcli connection down "${cn}"; systemctl restart NetworkManager; fi;}; send "\r\n"
								#expect -re {[>$#:] *$} { send "\r# Now you can take over the keyboard\r\n" }
							}
							"dracut:/#" {
								send "\r"
								puts $expect_out(buffer)
								exit 11
							}
							"Entering emergency mode." {
								send "\r"
								puts $expect_out(buffer)
								exit 11
							}
							"System Reboot" {
								send "\r\r"
								expect "* login:" {
									send "root\r"
									expect "Password:" {
										send "'"$defaultPasswd"'\r"
										expect -re {[>$#:] *$} { send "\r" }
									}
								}
							}
							"* login:" {
								send "root\r"
								expect "Password:" {
									send "'"$defaultPasswd"'\r"
									expect -re {[>$#:] *$} { send "\r" }
								}
							}
						}
						send "\r\r# Now you can take over the keyboard\r\r"
						send "# and you are in console, Ctr + ] to exit \r"
						expect -re {[>$#:] *$} { send "read -N 10000000 -t 0.001  #clear input buffer\r"; after 2 }
						send "\r\r"
					}

					if {$env(INTERACT) == "no"} { exit 0 }
					interact; exit
				'
				ReturnCode=$?
				[[ $ReturnCode = 0 || $ReturnCode = 255 ]] && break
				[[ $ReturnCode = 127 ]] && { virsh start $vmname 2>&1 | sed 's/error: //'; continue; }
				[[ $ReturnCode = 11 ]] && {
					[[ "$VM_RETRY" != yes ]] && env kill -q 127 -s SIGUSR2 $CPID
					break
				}
				sleep 2
			done

			echo -e "\n{VM:INFO} Quit from expect -c 'spawn virsh console $vmname'"
			[[ "$(vmstat $vmname)" = running* ]] || { vm start $vmname; }

			[[ -f "$cloudinitiso" && "$iso_bus_type" != *=usb ]] && {
				echo -e "\n{VM:INFO} eject iso ${cloudinitiso##*/} from $vmname"
				virsh change-media $vmname $cloudinitiso --eject 2>/dev/null
			}
			[[ "$(vmstat $vmname)" = running* ]] || { vm start $vmname; }
		fi
	fi
elif [[ "$InstallType" = pxe ]]; then
	if [[ -n "$TO_DISK" ]]; then
		imagefile="$TO_DISK"
	else
		imagefile=$VMpath/${vmname}.qcow2
		diskOpt=path=${imagefile},bus=virtio,size=${DSIZE}
		if [[ "$DISKLESS" = yes ]]; then
			diskOpt=none
		else
			qemu-img create -f qcow2 ${imagefile} ${DSIZE}G
		fi
	fi

	echo -e "{VM:INFO} creating VM from pxe"
	run -as=$VMUSER touch $VMpath/.kiss-vm

	ls -l ${imagefile}

	BOOT_DISK_OPT=
	if [[ -z "$NVME_BOOT" ]]; then
		BOOT_DISK_OPT="--disk $diskOpt"
	else
		[[ "$DISKLESS" != yes ]] && {
			setfacl -mu:${QEMU_USER}:rwx -mg:${QEMU_USER}:rwx $imagefile
			chcon system_u:object_r:qemu_var_run_t:s0 $imagefile 2>/dev/null #system_u:object_r:virt_cache_t:s0 also works
			QEMU_OPTS+=("--qemu-commandline=-drive file=$imagefile,format=qcow2,if=none,id=NVME0 -device nvme,drive=NVME0,serial=nvme-0,bootindex=0,addr=0x10")
		}
	fi

	LANGUAGE=C run -debug -nohup unbuffer virt-install --connect=qemu:///system $virtualizationOption --accelerate $XML \
	  --name $vmname \
	  $OS_VARIANT_OPT \
	  ${ARCH_OPT} \
	  $MACHINE_OPT \
	  --vcpus ${VCPUS} \
	  $MEM_OPTS \
	  --pxe \
	  $BOOT_DISK_OPT \
	  "${BOOT_OPTS[@]}" \
	  "${NETWORK_OPTS[@]}" \
	  "${HOST_DEV_OPTS[@]}" \
	  $VTPM_OPT \
	  ${VIDEO_OPT} \
	  ${SOUND_OPT} \
	  --noautoconsole --wait=-1 \
	  ${GRAPHICS_OPT:---graphics=${DEFAULT_GRAPHICS_CONF}} \
	  ${VIRT_CPU_OPT} \
	  "${VIRT_INSTALL_OPTS[@]}" \
	  "${QEMU_OPTS[@]}" "${QEMU_ENV[@]}" "${QEMU_QMP_MON_OPT[@]}"

	[[ -z "$XML" ]] && while true; do test -s $VMpath/nohup.log && break; done
	expect -c "spawn tail -f $VMpath/nohup.log
		set timeout $VirtInstallTimeOut
		expect {
			{Waiting for installation to complete} { exit }
			{Waiting for the installation to complete} { exit }
			{otherwise, please restart your installation} { exit }
			{</domain>} { exit }
			{ERROR } { exit }
			{*\r} { exp_continue }
		}
	"
	grep ^ERROR $VMpath/nohup.log && cleanup_and_exit 1
	[[ -n "$XML" ]] && {
		cp $VMpath/nohup.log $VMpath/vm.xml
		virsh domxml-to-native qemu-argv $VMpath/vm.xml | tee $VMpath/qemu-argv
		cleanup_and_exit &>/dev/null
	}

	sleep 1
	vm vnc $vmname -get

	if [[ -n $DISPLAY ]]; then
		run -debug -nohup=/dev/null virt-viewer -s -v -r $vmname
		echo -e "\n{VM:INFO} pxe guest $vmname booting ..."
	else
		echo -e "\n{VM:INFO} please connect vnc to continue/complete the install:"
		for vncaddr in $(vmvncproc $vmname); do
			echo -e "  $ vncviewer $vncaddr    #from remote"
		done
	fi

	if [[ "$NOAUTO" = yes ]]; then
		echo -e "{VM:INFO} waiting pxe boot/menu: prompt ..."
		for ((i=0; i<60; i++)) do grep -iq "pxe boot menu" < <(vm vnc "$vmname" -get) && break; sleep 1; done
		vm vnc $vmname -put=key:tab -put=key:esc
	else
		if [[ -n "${VNCWAIT_AFTER_INSTALL[*]}" ]]; then
			for pat_msg_timo in "${VNCWAIT_AFTER_INSTALL[@]}"; do
				IFS=, read _pattern _msgs _timo <<<"${pat_msg_timo}"
				echo -e "\n{VM:INFO} vncwait $_pattern ..."
				vm vnc $vmname -get
				for ((i=0; i<${_timo:-60}; i++)) do
					sleep 1; vm vnc "$vmname" -get | GREP_COLORS='ms=01;30;46' grep -i --color "$_pattern" && break
				done && for _send in $_msgs; do vm vnc "$vmname" -put "$_send"; done
				sleep 2
			done
		else
			echo -e "{VM:INFO} waiting pxe boot/menu: prompt ..."
			for ((i=0; i<60; i++)) do grep -iq "pxe boot menu" < <(vm vnc "$vmname" -get) && break; sleep 1; done
			vm vnc $vmname -put=key:enter
		fi
	fi

	exit 0
elif [[ "$InstallType" = cdrom_image ]]; then
	[[ -f $Isourl ]] && Isourl=file://$(readlink -f ${Isourl})
	isofilename=${Isourl##*/}
	isofilepath=$VMpath/$isofilename
	[[ "$DOWNLOAD_ONLY" = yes ]] && isofilepath=${DownloadImagePath%/}/${isofilename}

	echo "{VM:INFO} downloading iso file of $Distro to $isofilepath ..."
	if [[ $Isourl != file:///* ]]; then
		if [[ -n "$SAVE_IMAGE" ]]; then
			curl_download_x ${DownloadImagePath}/${isofilename} $Isourl
			[[ "$DOWNLOAD_ONLY" = yes ]] && {
				ls -l ${DownloadImagePath}/${isofilename}
				cleanup_and_exit 0
			}
			cp -v ${DownloadImagePath}/${isofilename} $isofilepath
			#fixme: ^^ performance improve?
		else
			curl_download_x $isofilepath $Isourl
		fi
	else
		cp -v -f ${Isourl#file://} $isofilepath
		#fixme: ^^ performance improve?
	fi
	[[ -f ${isofilepath} ]] || cleanup_and_exit 1
	ls -lhZ ${isofilepath}

	if [[ -n "$TO_DISK" ]]; then
		imagefile="$TO_DISK"
	else
		imagefile=$VMpath/${vmname}.qcow2
		qemu-img create -f qcow2 ${imagefile} ${DSIZE}G
	fi

	echo -e "{VM:INFO} creating VM install from cdrom/image($isofilepath)"
	run -as=$VMUSER touch $VMpath/.kiss-vm

	ls -lhZ ${imagefile}

	if [[ "$WIN_AUTO" = yes ]]; then
		run -as=$VMUSER touch $VMpath/ansf-usb.image
		WIN_USER=${WIN_USER:-Administrator}
		WIN_PASS=${WIN_PASS:-${defaultWindowsPasswd}}
		if [[ -z "$WIN_WIM_IMAGE_INDEX" ]]; then
			WIN_WIM_IMAGE_INDEX=4
			[[ "$VM_OS_VARIANT" = win10 || "${Distro,,}" =~ (win|windows-?)1[01] ]] && {
				WIN_WIM_IMAGE_INDEX=1; }
		fi
		WIN_WIM_IMAGE_INDEX_OPT="--wim-index=$WIN_WIM_IMAGE_INDEX"
		if [[ "$DFS" = yes && -z "$DFS_TARGET" ]]; then
			make-samba-server.sh --users=$WIN_USER,smbfoo,smbbar \
				--passwd=$WIN_PASS --group=${WIN_DOMAIN//./}
			DFS_TARGET=$HOSTNAME:pub
			WIN_DFS_TARGET_OPT="--dfs-target=$DFS_TARGET"
		fi
		[[ -n "$WIN_MAC_EXT" ]] && WIN_MAC_OPTS+=(--mac-ext=$WIN_MAC_EXT)
		[[ -n "$WIN_MAC_INT" ]] && WIN_MAC_OPTS+=(--mac-int=$WIN_MAC_INT)
		[[ -n "$WIN_STATIC_IP_EXT" ]] && WIN_STATIC_IP_OPTS+=(--static-ip-ext=$WIN_STATIC_IP_EXT)
		[[ -n "$WIN_STATIC_IP_INT" ]] && WIN_STATIC_IP_OPTS+=(--static-ip-int=$WIN_STATIC_IP_INT)
		#WIN_OpenSSH_OPT
		#WIN_VirtioDrv_OPT
		#WIN_LOCALE_OPT
		#WIN_KEY_OPT
		#WIN_DOMAIN_OPT
		#WIN_AD_FOREST_LEVEL_OPT
		#WIN_AD_DOMAIN_LEVEL_OPT
		#WIN_PARENT_DOMAIN_OPT
		#WIN_PARENT_IP_OPT
		#WIN_KDC_OPT
		#WIN_DL_URL_OPTS+
		#WIN_RUN_CMD_OPTS+
		#WIN_RUN_POST_CMD_OPTS+
		if [[ -z "$WIN_HOSTNAME" ]]; then
			WIN_HOSTNAME=${vmname,,}
			WIN_HOSTNAME=${WIN_HOSTNAME#${VMUSER}-};
			WIN_HOSTNAME=$(echo ${WIN_HOSTNAME}|sed -r 's/windows(-server)?-?/win/')
			[[ "${#WIN_HOSTNAME}" -gt 15 ]] && { WIN_HOSTNAME=${WIN_HOSTNAME:0:15}; }
		fi
		WIN_HOSTNAME_OPT="--hostname=${WIN_HOSTNAME}"
		case "${BOOT_OPTS[*]}" in (*uefi*|*firmware=efi*) WIN_UEFI_OPT="--uefi";; esac

		#virt-filesystems, virt-make-fs always hang on 'Fedora Linux Asahi Remix'
		grep -q Asahi /etc/os-release && NO_VIRT_TOOLS_OPT=--no-virt-tools
		case ${WIN_TEMPLATE} in
		base)
		    run -debug answer-file-generator.sh $WIN_HOSTNAME_OPT $WIN_DOMAIN_OPT $WIN_KEY_OPT \
			${WIN_UEFI_OPT} ${WIN_LOCALE_OPT} ${WIN_WIM_IMAGE_INDEX_OPT} \
			-u $WIN_USER -p "$WIN_PASS" "${WIN_OpenSSH_OPT[@]}" "${WIN_VirtioDrv_OPT[@]}" \
			"${WIN_DL_URL_OPTS[@]}" "${WIN_RUN_CMD_OPTS[@]}" "${WIN_RUN_POST_CMD_OPTS[@]}" \
			"${WIN_STATIC_IP_OPTS[@]}" "${WIN_MAC_OPTS[@]}" \
			--time-server=${TIME_SERVER} \
			--temp=${WIN_TEMPLATE} --path=$VMpath/ansf-usb.image $NO_VIRT_TOOLS_OPT;;
		cifs-nfs)
		    run -debug answer-file-generator.sh $WIN_HOSTNAME_OPT $WIN_DOMAIN_OPT $WIN_KEY_OPT \
			${WIN_UEFI_OPT} ${WIN_LOCALE_OPT} ${WIN_WIM_IMAGE_INDEX_OPT} \
			-u $WIN_USER -p "$WIN_PASS" "${WIN_OpenSSH_OPT[@]}" "${WIN_VirtioDrv_OPT[@]}" \
			${WIN_KDC_OPT} ${WIN_DFS_TARGET_OPT} \
			"${WIN_DL_URL_OPTS[@]}" "${WIN_RUN_CMD_OPTS[@]}" "${WIN_RUN_POST_CMD_OPTS[@]}" \
			"${WIN_STATIC_IP_OPTS[@]}" "${WIN_MAC_OPTS[@]}" \
			--time-server=${TIME_SERVER} \
			--temp=${WIN_TEMPLATE} --path=$VMpath/ansf-usb.image $NO_VIRT_TOOLS_OPT;;
		addsdomain|addsforest)
		    run -debug answer-file-generator.sh $WIN_HOSTNAME_OPT $WIN_DOMAIN_OPT $WIN_KEY_OPT \
			${WIN_UEFI_OPT} ${WIN_LOCALE_OPT} ${WIN_WIM_IMAGE_INDEX_OPT} \
			-u $WIN_USER -p "$WIN_PASS" "${WIN_OpenSSH_OPT[@]}" "${WIN_VirtioDrv_OPT[@]}" \
			${WIN_PARENT_DOMAIN_OPT} ${WIN_PARENT_IP_OPT} \
			${WIN_AD_DOMAIN_LEVEL_OPT} ${WIN_AD_FOREST_LEVEL_OPT} \
			"${WIN_DL_URL_OPTS[@]}" "${WIN_RUN_CMD_OPTS[@]}" "${WIN_RUN_POST_CMD_OPTS[@]}" \
			"${WIN_STATIC_IP_OPTS[@]}" "${WIN_MAC_OPTS[@]}" \
			--time-server=${TIME_SERVER} \
			--temp=${WIN_TEMPLATE} --path=$VMpath/ansf-usb.image $NO_VIRT_TOOLS_OPT;;
		*)
		    echo "{ERROR} unsupported answerfile template (${WIN_TEMPLATE})" >&2
		    false;;
		esac
		[[ $? -ne 0 ]] && cleanup_and_exit 1

		ANSF_DISK_OPT="--disk path=$VMpath/ansf-usb.image,bus=usb,removable=on"
	fi

	BOOT_DISK_OPT=
	if [[ -z "$NVME_BOOT" ]]; then
		BOOT_DISK_OPT="--disk path=${imagefile},${BOOT_DISK_ATTRS}"
	else
		setfacl -mu:${QEMU_USER}:rwx -mg:${QEMU_USER}:rwx $imagefile
		chcon system_u:object_r:qemu_var_run_t:s0 $imagefile 2>/dev/null #system_u:object_r:virt_cache_t:s0 also works
		QEMU_OPTS+=("--qemu-commandline=-drive file=$imagefile,format=qcow2,if=none,id=NVME0 -device nvme,drive=NVME0,serial=nvme-0,bootindex=0,addr=0x10")
	fi

	bootOption="--cdrom $isofilepath"
	if LANG=C file -b --mime-type $isofilepath | grep -q iso; then
		[[ -n "$CDROM_BUS_TYPE" ]] && bootOption="--import --disk path=$isofilepath,device=cdrom,bus=${CDROM_BUS_TYPE}"
	else
		bootOption="--import --disk path=$isofilepath,$BOOT_DISK_ATTRS"
	fi
	LANGUAGE=C run -debug -nohup unbuffer virt-install --connect=qemu:///system $virtualizationOption --accelerate $XML \
	  --name $vmname \
	  $OS_VARIANT_OPT \
	  ${ARCH_OPT} \
	  $MACHINE_OPT \
	  --vcpus ${VCPUS} \
	  $MEM_OPTS \
	  $bootOption \
	  $BOOT_DISK_OPT \
	  $ANSF_DISK_OPT \
	  "${BOOT_OPTS[@]}" \
	  $DISK_OPTS \
	  "${NETWORK_OPTS[@]}" \
	  $CONTROLLER_OPTS \
	  "${HOST_DEV_OPTS[@]}" \
	  $VTPM_OPT \
	  ${VIDEO_OPT} \
	  ${SOUND_OPT} \
	  --noautoconsole --wait=-1 \
	  ${GRAPHICS_OPT:---graphics=${DEFAULT_GRAPHICS_CONF}} \
	  ${VIRT_CPU_OPT} \
	  "${VIRT_INSTALL_OPTS[@]}" \
	  "${QEMU_OPTS[@]}" "${QEMU_ENV[@]}" "${QEMU_QMP_MON_OPT[@]}"

	[[ -z "$XML" ]] && while true; do test -s $VMpath/nohup.log && break; done
	expect -c "spawn tail -f $VMpath/nohup.log
		set timeout $VirtInstallTimeOut
		expect {
			{Waiting for installation to complete} { exit }
			{Waiting for the installation to complete} { exit }
			{otherwise, please restart your installation} { exit }
			{</domain>} { exit }
			{ERROR } { exit }
			{Restarting guest} {exit}
			{*\r} { exp_continue }
		}
	"
	grep ^ERROR $VMpath/nohup.log && cleanup_and_exit 1
	[[ -n "$XML" ]] && {
		cp $VMpath/nohup.log $VMpath/vm.xml
		virsh domxml-to-native qemu-argv $VMpath/vm.xml | tee $VMpath/qemu-argv
		cleanup_and_exit &>/dev/null
	}

	vm vnc $vmname -put "key:shift"
	vm vnc $vmname -get | tee $RuntimeTmp/std.log
	if grep -Eq 'No bootable device' $RuntimeTmp/std.log; then
		[[ "$VM_RETRY" != yes ]] && env kill -q 127 -s SIGALRM $CPID
	fi

	if [[ "$WIN_AUTO" = yes ]]; then
		run -tmux=langselect_$vmname 'vmn='"$vmname"'
		for ((i=0; i<32; i++)); do
			scocr=$(vm vnc $vmn -get -ocr-tool=tesseract)
			case "${scocr,,}" in
			*lan9*|*langua*|*l?ngua*)
				echo "$scocr"
				vm vnc $vmn -put=key:tab -put=key:tab -put=key:tab -put=key:enter
				break;;
			*)
				sleep 5;;
			esac
		done'
		run -tmux=key-ask_$vmname 'sleep 64; vmn='"$vmname"'
		for ((i=0; i<180; i++)); do
			scocr=$(vm vnc $vmn -get -ocr-tool=tesseract)
			case "${scocr,,}" in
			*type?your?windows?product?key*|*20000-2000*|*x000*0000*windows?a?*|*xxxxxxxxxxxxxxxxxxxxx*)
				echo "$scocr"
				tmux kill-session -t langselect_$vmn 2>/dev/null
				vm vnc $vmn -put=key:alt-tab -put=emm
				vm vnc $vmn -put=key:tab -put=key:tab -put=key:tab -put=key:tab -put=key:enter
				break;;
			*)
				sleep 10;;
			esac
		done'
		run -tmux=virtio-win-install_$vmname 'sleep 180; vmn='"$vmname"'; temp='"$WIN_TEMPLATE"'
		for ((i=0; i<1440; i++)); do
			[[ "$temp" != base ]] && break
			scocr=$(vm vnc $vmn -get -ocr-tool=tesseract)
			case "${scocr,,}" in
			*v?rt?o?w?n??nstall?done*) break;;
			*stat?c??p*) break;;
			*red?h?*vi?*red?hat*?nc*red??at*?nc*|*ed*ha*,?inc*software?from?publ*shers?you?trust*)
				echo "--------[$(date +%F_%T)]------------------------------------------"
				echo "$scocr"
				[[ "$scocr" = "$pre" ]] && vm vnc $vmn -put=key:alt-tab || pre="${scocr}"
				vm vnc $vmn -put=key:tab -put=key:tab -put=" " -put=key:tab -put=key:enter
				;;
			*)
				vm vnc $vmn -put=key:alt-tab
				;;
			esac
			vm port-available $vmn 22 &>/dev/null && break
		done'
	fi

	if [[ -n "${VNCWAIT_AFTER_INSTALL[*]}" ]]; then
		for pat_msg_timo in "${VNCWAIT_AFTER_INSTALL[@]}"; do
			IFS=, read _pattern _msgs _timo <<<"${pat_msg_timo}"
			echo -e "\n{VM:INFO} vncwait $_pattern ..."
			vm vnc $vmname -get
			for ((i=0; i<${_timo:-60}; i++)) do
				sleep 1; vm vnc "$vmname" -get | GREP_COLORS='ms=01;30;46' grep -i --color "$_pattern" && break
			done && for _send in $_msgs; do vm vnc "$vmname" -put "$_send"; done
			sleep 2
		done
	fi
	if [[ -n "$VNCPUT_AFTER_INSTALL" ]]; then
		vm vnc "$vmname" -put "$VNCPUT_AFTER_INSTALL"
	fi

	if [[ -n $DISPLAY ]]; then
		run -debug -nohup=/dev/null virt-viewer -s -v -r $vmname
	else
		echo -e "\n{VM:INFO} please connect vnc to continue install:"
		for vncaddr in $(vmvncproc $vmname); do
			echo -e "  $ vncviewer $vncaddr    #from remote"
		done
	fi

	#exit 0
fi
trap - SIGINT SIGQUIT SIGTERM

if ! virsh desc $vmname &>/dev/null; then
	echo -e "\n{VM:ERR} virt-install fail" >&2
	rm -rf $VMpath $varlib_dir/$vmname && rmdir {$VMpath%/*} 2>/dev/null
	exit 1
fi

if [[ "$WAIT" = yes ]]; then
	echo -e "\n{VM:INFO} [$(date +%F_%T)] waiting port($WAIT_PORT) of $vmname available ..."
	if [[ "$WIN_AUTO" = yes ]]; then
		for ((i=0; i<60; i++)); do
			sleep 5
			timeout 5 vm vnc $vmname -get 2>/dev/null|grep -E 'Cii_.*L9.._i_.*\^.*L9.*ie3.*iv_..L3' && {
				echo -e "\n{VM:ERR} your windows image is not Evaluation version, and no ProductKey was found from answerfile" >&2
				exit 1
			}
		done
	fi
	vm port-available $vmname $WAIT_PORT -w
	[[ $? = 0 && "$WIN_AUTO" = yes ]] && {
		echo -e "{VM:INFO} [$(date +%F_%T)] port($WAIT_PORT) of $vmname now is available"
		kill_installer_tmux_session ${vmname}
		win-env-file-gen.sh $vmname
	}
fi

#only for Fedora/RHEL/CentOS/RockyLinux/AlmaLinux
case ${Distro,,} in
fedora*|rhel*|centos*|rocky*|alma*|anolis*)
	for postrepo in "${POST_REPOS[@]}"; do
		_name=
		_url=
		if [[ "$postrepo" =~ ^[^:]+:(https|http|ftp|file):// ]]; then
			read _name _url _ <<<"${postrepo/:/ }"
		elif [[ "$postrepo" =~ ^(https|http|ftp|file):// ]]; then
			_name=repo-$RADOM
			_url=$postrepo
		fi

		[[ -z "$_name" || -z "$_url" ]] && continue

		repofpath=$VMpath/$_name.repo
		cat <<-REPO >$repofpath
		[$_name]
		name=$_name
		baseurl=$_url
		enabled=1
		gpgcheck=0
		skip_if_unavailable=1
		REPO
		vm cpto $vmname $repofpath /etc/yum.repos.d
		rm -f $repofpath
	done

	[[ ${#TASK[@]} -gt 0 ]] && {
		vm exec -v $vmname -- taskfetch.sh "${TASK[@]}" ${RUN_TASK:+--run}
	}
esac

if [[ "$GenerateImage" = yes ]]; then
	run -as=$VMUSER mkdir -p $ImagePath/$Distro
	read _type _dev _target image < <(_vmblklist $vmname '\.(qcow2|qcow|raw)')
	imgfilename=${image##*/}
	imgfilename=${imgfilename#${VMUSER}-}
	[[ "$imgfilename" != *${GuestARCH}* ]] && imgfilename=$(echo $imgfilename|sed -r "s/\\.[^.]+$/.${GuestARCH}&/")
	newimage=$ImagePath/$Distro/${imgfilename}

	echo -e "\n{VM:INFO} force shutdown $vmname ..."
	virsh destroy $vmname 2>/dev/null
	ls -lh ${image}

	if ! true; then
		echo -e "\n{VM:INFO} copy image $image to ${newimage} ..."
		cp ${image} ${newimage}
	else
		echo -e "\n{VM:INFO} virt-sparsify image $image to ${newimage} ..."
		#LIBGUESTFS_BACKEND=direct virt-sparsify --check-tmpdir fail --tmp "$VMpath/tmp" ${image} ${newimage} || {
		LIBGUESTFS_BACKEND=direct virt-sparsify --check-tmpdir fail ${image} ${newimage} || {
			ls -lh ${image}
			cp ${image} ${newimage}
			LIBGUESTFS_BACKEND=direct virt-sparsify --in-place ${newimage}
		}
		ls -lh ${image}
		ls -lh ${newimage}
	fi

	echo -e "\n{VM:INFO} virt-sysprep ..."
	ls -lh ${newimage}
	LIBGUESTFS_BACKEND=direct virt-sysprep -a ${newimage}
	ls -lh ${newimage}

	echo -e "\n{VM:INFO} xz compress image ..."
	time xz -z -f -T 0 ${XZ:--6} ${newimage}
	ls -lh ${newimage}.xz

	echo -e "\n{VM:INFO} remove temporary VM $vmname ..."
	_vmdelete $vmname
	exit 0
fi

if [[ "$RM" = yes ]]; then
	_vmdelete $vmname
	exit 0
fi

vm_add_virtiofs_sharedir() {
	local vmname=$1
	local srcdir=$2
	local rtarget=$3
	local target=virtiofs-tag-$rtarget
	local xmlf=${VMpath:-/tmp}/${target}.xml

	cat >${xmlf} <<-EOF
	<filesystem type='mount' accessmode='passthrough'>
		<binary path='/usr/libexec/virtiofsd' xattr='on'/>
		<driver type='virtiofs'/>
		<source dir='$srcdir'/>
		<target dir='$target'/>
	</filesystem>
	EOF
	virsh attach-device $vmname ${xmlf} --persistent
	virsh attach-device $vmname ${xmlf} --live

	local mp=/virtiofs/$rtarget
	vm exec -v $vmname -- mkdir -p $mp
	vm exec -v $vmname -- mount -t virtiofs $target $mp
	vm exec -v $vmname -- mount -t virtiofs
}

if vercmp "$(libvirt_nvr)" ge libvirt-7.9; then
#only for linux virtiofs
[[ ${#SHARE_DIRS[@]} -gt 0 ]] && {
	for idx in "${!SHARE_DIRS[@]}"; do
		read srcdir rtarget _ <<< "${SHARE_DIRS[$idx]//:/ }"
		run -as=$VMUSER mkdir -p $srcdir || continue
		vm_add_virtiofs_sharedir $vmname $srcdir ${rtarget:-tag$idx}
	done
}
else
#only for linux virtiofs, related bug: rhel/fedora 1897708 1897710
[[ ${#SHARE_DIRS[@]} -gt 0 ]] && {
	vm stop $vmname

	for idx in "${!SHARE_DIRS[@]}"; do
		read srcdir rtarget _ <<< "${SHARE_DIRS[$idx]//:/ }"
		rtarget=${rtarget:-tag$idx}
		target=virtiofs-tag-$rtarget
		run -as=$VMUSER mkdir -p $srcdir
		cat >virtiofs.xml <<-EOF
		<filesystem type='mount' accessmode='passthrough'>
			<binary path='/usr/libexec/virtiofsd' xattr='on'/>
			<driver type='virtiofs'/>
			<source dir='$srcdir'/>
			<target dir='$target'/>
		</filesystem>
		EOF
		virsh attach-device $vmname virtiofs.xml --persistent
	done

	vm reboot -w $vmname

	for idx in "${!SHARE_DIRS[@]}"; do
		read _ rtarget _ <<< "${SHARE_DIRS[$idx]//:/ }"
		rtarget=${rtarget:-tag$idx}
		target=virtiofs-tag-$rtarget
		mp=/virtiofs/$rtarget
		vm exec -v $vmname -- mkdir -p $mp
		vm exec -v $vmname -- mount -t virtiofs $target $mp
		vm exec -v $vmname -- mount -t virtiofs
	done
}
fi

if [[ ! -f ~/.ssh/config ]]; then
	cat <<-EOF > ~/.ssh/config
	Host 192.168.*.*
	   StrictHostKeyChecking no
	   UserKnownHostsFile=/dev/null
	   LogLevel ERROR

	Host 172.*.*.*
	   StrictHostKeyChecking no
	   UserKnownHostsFile=/dev/null
	   LogLevel ERROR

	Host 10.*.*.*
	   StrictHostKeyChecking no
	   UserKnownHostsFile=/dev/null
	   LogLevel ERROR
	EOF
	chmod 600 ~/.ssh/config
fi

#only for linux
[[ -n "$DEFAULT_KERNEL" ]] && {
	vm exec -v $vmname -- uname -r
	vm exec -v $vmname -- grubby --default-kernel
	vm exec -v $vmname -- grubby --default-index
	vm exec -v $vmname -- grubby --info=ALL

	pat=${DEFAULT_KERNEL#kernel-}
	defaultIndex=$(vm exec $vmname -- grubby --default-index)
	expectedIndex=$(vm exec $vmname -- grubby --info=ALL | sed 's/^index=/\n/' |
		awk 'BEGIN{RS=""; FS="\n"} '"/$pat/"'{print $1}')

	if [[ "$defaultIndex" != "$expectedIndex" ]]; then
		vm exec -v $vmname -- grubby --set-default-index=$expectedIndex
		REBOOT=yes
	fi
	if ! vm exec $vmname -- uname -r | grep "$pat"; then
		REBOOT=yes
	fi
}
[[ "$REBOOT" = yes ]] && {
	vm exec -v $vmname -- "reboot; exit"
	read _vmaddr < <(vmifaddr "$vmname")
	until port_available ${_vmaddr} 22; do sleep 1; done
}

[[ "$(vmstat $vmname)" = running* ]] || { vm start $vmname; }
echo -e "\n{VM:INFO} you can try login $vmname again by using:"
echo -e "  $ vm login $vmname          #from host"
for vncaddr in $(vmvncproc $vmname); do
	if [[ "$vncaddr" = localhost* ]]; then
		echo -e "  $ vncviewer $vncaddr    #from localhost"
	else
		echo -e "  $ vncviewer $vncaddr    #from localhost or remote"
	fi
done
read -N 10000000 -t 0.001  #clear input buffer
exit 0
